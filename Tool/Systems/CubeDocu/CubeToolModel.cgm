! Generated with CubeGen
+META_MODEL:CUBE;
	+META_TYPE:INFORMATION_TYPE|;
		=PROPERTY:0|Name|;
		+META_TYPE:INFORMATION_TYPE_ELEMENT|;
			=PROPERTY:0|Sequence|;
			=PROPERTY:1|Suffix|;
			=PROPERTY:2|Domain| Values: TEXT(Text), NUMBER(Number), DATE(Date), TIME(Time), DATETIME-LOCAL(Timestamp);
			=PROPERTY:3|Length|;
			=PROPERTY:4|Decimals|;
			=PROPERTY:5|CaseSensitive| Values: Y(Yes), N(No);
			=PROPERTY:6|DefaultValue|;
			=PROPERTY:7|SpacesAllowed| Values: Y(Yes), N(No);
			=PROPERTY:8|Presentation|Indication how the string is presented in the user dialog. Values: LIN(Line), DES(Description), COD(Code);
			+META_TYPE:PERMITTED_VALUE|;
				=PROPERTY:0|Code|;
				=PROPERTY:1|Prompt|;
			-META_TYPE:PERMITTED_VALUE;
		-META_TYPE:INFORMATION_TYPE_ELEMENT;
	-META_TYPE:INFORMATION_TYPE;
	+META_TYPE:BUSINESS_OBJECT_TYPE|An object type related to the business supported by the system.;
		=PROPERTY:0|Name|;
		=PROPERTY:1|CubeTsgType| Values: INT(INTERNAL), EXT(EXTERNAL);
		=PROPERTY:2|Directory|;
		=PROPERTY:3|ApiUrl|The basic URL for calling the API.;
		+META_TYPE:TYPE|An entity type related to the business that is supported by the system.;
			=PROPERTY:0|Name|;
			=PROPERTY:1|Code|;
			=PROPERTY:2|FlagPartialKey| Values: Y(Yes), N(No);
			=PROPERTY:3|FlagRecursive| Values: Y(Yes), N(No);
			=PROPERTY:4|RecursiveCardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
			=PROPERTY:5|Cardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
			=PROPERTY:6|SortOrder| Values: N(No sort), K(Key), P(Position);
			=PROPERTY:7|Icon|;
			=PROPERTY:8|Transferable|Indication that in case of a recursive type the type may moved to an other parent in the hierarchy. Values: Y(Yes), N(No);
			+META_TYPE:ATTRIBUTE|;
				=PROPERTY:0|Name|Unique identifier of the attribute.;
				=PROPERTY:1|PrimaryKey|Indication that attribute is part of the unique identification of the type. Values: Y(Yes), N(No);
				=PROPERTY:2|CodeDisplayKey| Values: Y(Yes), S(Sub), N(No);
				=PROPERTY:3|CodeForeignKey| Values: N(None);
				=PROPERTY:4|FlagHidden| Values: Y(Yes), N(No);
				=PROPERTY:5|DefaultValue|Defaut value that overules the default value specified by the information type element.;
				=PROPERTY:6|Unchangeable|Indication that after the creation of the type the value of the atrribute can not be changed. Values: Y(Yes), N(No);
				=ASSOCIATION:INFORMATION_TYPE|HasDomain|INFORMATION_TYPE|;
				+META_TYPE:DERIVATION|;
					=PROPERTY:0|CubeTsgType| Values: DN(DENORMALIZATION), IN(INTERNAL), AG(AGGREGATION);
					=PROPERTY:1|AggregateFunction| Values: SUM(Sum), AVG(Average), MIN(Minimum), MAX(Maximum);
					=ASSOCIATION:DERIVATION_TYPE|ConcernsParent|TYPE|;
					=ASSOCIATION:DERIVATION_TYPE_CONCERNS_CHILD|ConcernsChild|TYPE|;
				-META_TYPE:DERIVATION;
				+META_TYPE:DESCRIPTION_ATTRIBUTE|;
					=PROPERTY:0|Text|;
				-META_TYPE:DESCRIPTION_ATTRIBUTE;
				+META_TYPE:RESTRICTION_TYPE_SPEC_ATB|;
					=PROPERTY:0|IncludeOrExclude|Indication that the attribute is valid (included) or invalid (excluded) for the concerning type specialisation. Values: IN(Include), EX(Exclude);
					=ASSOCIATION:TYPE_SPECIALISATION|IsValidFor|TYPE_SPECIALISATION|;
				-META_TYPE:RESTRICTION_TYPE_SPEC_ATB;
			-META_TYPE:ATTRIBUTE;
			+META_TYPE:REFERENCE|;
				=PROPERTY:0|Name|;
				=PROPERTY:1|PrimaryKey|Indication that reference is part of the unique identification of the type. Values: Y(Yes), N(No);
				=PROPERTY:2|CodeDisplayKey| Values: Y(Yes), S(Sub), N(No);
				=PROPERTY:3|Sequence|;
				=PROPERTY:4|Scope|In case of a recursive target%2C the definition of the collection of the types to select. Values: ALL(All), ENC(Encapsulated), PRA(Parents all), PR1(Parents first level), CHA(Children all), CH1(Children first level);
				=PROPERTY:5|Unchangeable|Indication that after the creation of the type the reference can not be changed. So in case of a recursive reference the indication too that the relation is used to select the parents or children in the hierarchy. Values: Y(Yes), N(No);
				=PROPERTY:6|WithinScopeLevel|In case of recursive %22within scope of%22 type the relative level in the hierarchy%2C Positive numbers are the parent levels%2C Negative numbers are the child levels.;
				=ASSOCIATION:REFERENCE_TYPE|Refer|TYPE|The target entity type of the reference.;
				=ASSOCIATION:REFERENCE_TYPE_WITHIN_SCOPE_OF|WithinScopeOf|TYPE|In case of non recursive target or a scope all recursive target the common type for the selection.;
				+META_TYPE:DESCRIPTION_REFERENCE|;
					=PROPERTY:0|Text|;
				-META_TYPE:DESCRIPTION_REFERENCE;
				+META_TYPE:RESTRICTION_TYPE_SPEC_REF|;
					=PROPERTY:0|IncludeOrExclude|Indication that the reference is valid (included) or invalid (excluded) for the concerning type specialisation. Values: IN(Include), EX(Exclude);
					=ASSOCIATION:TYPE_SPECIALISATION|IsValidFor|TYPE_SPECIALISATION|;
				-META_TYPE:RESTRICTION_TYPE_SPEC_REF;
			-META_TYPE:REFERENCE;
			+META_TYPE:RESTRICTION_TYPE_SPEC_TYP|;
				=PROPERTY:0|IncludeOrExclude|Indication that the child type is valid (included) or invalid (excluded) for the concerning type specialisation. Values: IN(Include), EX(Exclude);
				=ASSOCIATION:TYPE_SPECIALISATION|IsValidFor|TYPE_SPECIALISATION|;
			-META_TYPE:RESTRICTION_TYPE_SPEC_TYP;
			+META_TYPE:TYPE_REUSE|;
				=PROPERTY:0|Cardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
				=ASSOCIATION:TYPE_REUSE_TYPE|Refer|TYPE|;
			-META_TYPE:TYPE_REUSE;
			+META_TYPE:PARTITION|;
				=PROPERTY:0|Name|;
				+META_TYPE:SUBTYPE|;
					=PROPERTY:0|Name|;
				-META_TYPE:SUBTYPE;
			-META_TYPE:PARTITION;
			+META_TYPE:TYPE_SPECIALISATION_GROUP|A group of classifications of the type.;
				=PROPERTY:0|Code|;
				=PROPERTY:1|Name|;
				=PROPERTY:2|PrimaryKey|Indication that the type specification group is part of the unique identification of the type. Values: Y(Yes), N(No);
				=ASSOCIATION:ATTRIBUTE|IsLocatedAfter|ATTRIBUTE|Defines the location of the classifying attribute within the type.;
				+META_TYPE:TYPE_SPECIALISATION|A classification of the type.;
					=PROPERTY:0|Code|;
					=PROPERTY:1|Name|;
					=ASSOCIATION:TYPE_SPECIALISATION|Specialise|TYPE_SPECIALISATION|;
				-META_TYPE:TYPE_SPECIALISATION;
			-META_TYPE:TYPE_SPECIALISATION_GROUP;
			+META_TYPE:DESCRIPTION_TYPE|Test%0D%0AMet LF en %22 en %27  en %25    %25%0D%0AEInde;
				=PROPERTY:0|Text|;
			-META_TYPE:DESCRIPTION_TYPE;
		-META_TYPE:TYPE;
	-META_TYPE:BUSINESS_OBJECT_TYPE;
	+META_TYPE:CUBE_GEN_DOCUMENTATION|A document to give an explanation of CubeGen based on examples.;
		=PROPERTY:0|Name|The name of the document.;
		=PROPERTY:1|Description|;
		=PROPERTY:2|DescriptionFunctions|Description for Template Function chapter.;
		=PROPERTY:3|DescriptionLogicalExpression|Description for Template Logical Functions chapter.;
		+META_TYPE:CUBE_GEN_PARAGRAPH|;
			=PROPERTY:0|Id|Technical identifier.;
			=PROPERTY:1|Header|Text used as header and used in the index.;
			=PROPERTY:2|Description|;
			=PROPERTY:3|Example|An example to explain the paragraph. No example is indicated by a %27%23%27.;
		-META_TYPE:CUBE_GEN_PARAGRAPH;
		+META_TYPE:CUBE_GEN_EXAMPLE_MODEL|A view on the business object model with examples of functions based on the business object model.;
			=PROPERTY:0|Id|Technical identifier.;
			=PROPERTY:1|Header|Text used as header and used in the index.;
			=PROPERTY:2|IncludedObjectNames|The names of types that are included in the view of the business object model.;
			=PROPERTY:3|Description|;
			+META_TYPE:CUBE_GEN_EXAMPLE_OBJECT|A reference to a business object that is used in the examples.;
				=ASSOCIATION:BUSINESS_OBJECT_TYPE|UsesAsExample|BUSINESS_OBJECT_TYPE|;
			-META_TYPE:CUBE_GEN_EXAMPLE_OBJECT;
			+META_TYPE:CUBE_GEN_FUNCTION|A CubeGen function that has been explained with a template.;
				=PROPERTY:0|Id|Technical identifier.;
				=PROPERTY:1|Header|Text used as header and used in the index.;
				=PROPERTY:2|Description|;
				=PROPERTY:3|Template|CubeGen template used as example.;
			-META_TYPE:CUBE_GEN_FUNCTION;
		-META_TYPE:CUBE_GEN_EXAMPLE_MODEL;
		+META_TYPE:CUBE_GEN_TEMPLATE_FUNCTION|;
			=PROPERTY:0|Name|;
			=PROPERTY:1|IndicationLogical|Indication that the function is a locical expression used in a condition. Values: Y(Yes), N(No);
			=PROPERTY:2|Description|;
			=PROPERTY:3|Syntax|;
		-META_TYPE:CUBE_GEN_TEMPLATE_FUNCTION;
	-META_TYPE:CUBE_GEN_DOCUMENTATION;
	+META_TYPE:SYSTEM|;
		=PROPERTY:0|Name|;
		=PROPERTY:1|Database|;
		=PROPERTY:2|Schema|;
		=PROPERTY:3|Password|;
		+META_TYPE:SYSTEM_BO_TYPE|;
			=ASSOCIATION:BUSINESS_OBJECT_TYPE|Has|BUSINESS_OBJECT_TYPE|;
		-META_TYPE:SYSTEM_BO_TYPE;
	-META_TYPE:SYSTEM;
-META_MODEL:CUBE;
+BUSINESS_OBJECT_TYPE[BOT-000000100040]:CUSTOMER|EXT|customer_files|;
	+TYPE[TYP-000000100021]:CUSTOMER|CUS|N|N|N|N|N||Y;
		+ATTRIBUTE[ATB-000000100004]:RELATION_NUMBER|Y|Y|N|N||N;
		-ATTRIBUTE:RELATION_NUMBER;
		+ATTRIBUTE[ATB-000000100001]:NAME|N|N|N|N||N;
		-ATTRIBUTE:NAME;
	-TYPE:CUSTOMER;
-BUSINESS_OBJECT_TYPE:CUSTOMER;
+BUSINESS_OBJECT_TYPE[BOT-000000100024]:ORDER|INT|order_directory|;
	+TYPE[TYP-000000100020]:ORDER|ORD|N|N|N|N|N||Y;
		+ATTRIBUTE[ATB-000000100005]:NUMBER|N|N|N|N||N;
		-ATTRIBUTE:NUMBER;
		+ATTRIBUTE[ATB-000000100006]:DELIVERY_DATE|N|N|N|N||N;
		-ATTRIBUTE:DELIVERY_DATE;
		+ATTRIBUTE[ATB-000000100003]:DESCRIPTION|N|N|N|N||N;
		-ATTRIBUTE:DESCRIPTION;
		+REFERENCE[REF-000000100000]:IS_PLACED_BY|N|N|0|ALL|N|0;
			>REFERENCE_TYPE:TYP-000000100021;
		-REFERENCE:IS_PLACED_BY;
		+TYPE[TYP-000000100022]:ORDER_LINE|ORL|Y|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100020]:NUMBER|Y|N|N|N||N;
			-ATTRIBUTE:NUMBER;
			+ATTRIBUTE[ATB-000000100021]:DESCRIPTION|N|N|N|N||N;
			-ATTRIBUTE:DESCRIPTION;
			+REFERENCE[REF-000000100001]:CONCERNS|Y|Y|0|ALL|N|0;
				>REFERENCE_TYPE:TYP-000000100000;
			-REFERENCE:CONCERNS;
		-TYPE:ORDER_LINE;
	-TYPE:ORDER;
-BUSINESS_OBJECT_TYPE:ORDER;
+BUSINESS_OBJECT_TYPE[BOT-000000100025]:PRODUCT|INT|product_definitions|;
	+TYPE[TYP-000000100000]:PRODUCT|PRD|Y|N|N|N|N|PRODUCT|Y;
		+ATTRIBUTE[ATB-000000100007]:CODE|Y|Y|N|N||N;
		-ATTRIBUTE:CODE;
		+TYPE[TYP-000000100004]:PRODUCT_PART_APPLICATION|PPA|Y|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100008]:CODE|Y|N|N|N||N;
			-ATTRIBUTE:CODE;
			+ATTRIBUTE[ATB-000000100010]:COUNT|N|N|N|N||N;
			-ATTRIBUTE:COUNT;
		-TYPE:PRODUCT_PART_APPLICATION;
		+TYPE[TYP-000000100002]:PRODUCTION_PROCES|PPR|N|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100012]:PROCES_ID|Y|N|N|N||N;
			-ATTRIBUTE:PROCES_ID;
			+TYPE[TYP-000000100003]:PRODUCTION_PROCES_STEP|PPS|N|N|N|N|N||Y;
				+ATTRIBUTE[ATB-000000100013]:PROCES_STEP_ID|Y|N|N|N||N;
				-ATTRIBUTE:PROCES_STEP_ID;
				+ATTRIBUTE[ATB-000000100014]:DESCRIPTION|N|N|N|N||N;
				-ATTRIBUTE:DESCRIPTION;
			-TYPE:PRODUCTION_PROCES_STEP;
		-TYPE:PRODUCTION_PROCES;
	-TYPE:PRODUCT;
-BUSINESS_OBJECT_TYPE:PRODUCT;
+BUSINESS_OBJECT_TYPE[BOT-000000100100]:FACTORY|INT|production_locations|;
	+TYPE[TYP-000000100100]:FACTORY|FCT|N|N|N|N|N||Y;
		+TYPE[TYP-000000100101]:FACTORY_HALL|FCH|N|N|N|N|N||Y;
		-TYPE:FACTORY_HALL;
	-TYPE:FACTORY;
-BUSINESS_OBJECT_TYPE:FACTORY;
+BUSINESS_OBJECT_TYPE[BOT-000000100060]:AAA|INT|<b>Bold</b><br>Normal|;
	+TYPE[TYP-000000100040]:AAA|AAA|N|N|N|N|N||Y;
		+TYPE[TYP-000000100041]:BBB1|BB1|N|N|N|N|N||Y;
			+TYPE[TYP-000000100048]:CCC11|C11|N|N|N|N|N||Y;
				+TYPE[TYP-000000100057]:DDD111|D01|N|N|N|N|N||Y;
				-TYPE:DDD111;
			-TYPE:CCC11;
			+TYPE[TYP-000000100049]:CCC12|C12|N|N|N|N|N||Y;
				+TYPE[TYP-000000100063]:DDD121|D11|N|N|N|N|N||Y;
				-TYPE:DDD121;
				+TYPE[TYP-000000100062]:DDD122|D12|N|N|N|N|N||Y;
				-TYPE:DDD122;
			-TYPE:CCC12;
			+TYPE[TYP-000000100050]:CCC13|C13|N|N|N|N|N||Y;
				+TYPE[TYP-000000100064]:DDD131|D21|N|N|N|N|N||Y;
				-TYPE:DDD131;
				+TYPE[TYP-000000100065]:DDD132|D22|N|N|N|N|N||Y;
				-TYPE:DDD132;
				+TYPE[TYP-000000100066]:DDD133|D23|N|N|N|N|N||Y;
				-TYPE:DDD133;
			-TYPE:CCC13;
		-TYPE:BBB1;
		+TYPE[TYP-000000100042]:BBB2|BB2|N|N|N|N|N||Y;
			+TYPE[TYP-000000100051]:CCC21|C21|N|N|N|N|N||Y;
			-TYPE:CCC21;
			+TYPE[TYP-000000100052]:CCC22|C22|N|N|N|N|N||Y;
			-TYPE:CCC22;
			+TYPE[TYP-000000100053]:CCC23|C2|N|N|N|N|N||Y;
			-TYPE:CCC23;
		-TYPE:BBB2;
	-TYPE:AAA;
-BUSINESS_OBJECT_TYPE:AAA;
+CUBE_GEN_DOCUMENTATION[CUB-000000100022]:Cube_Gen_Manual|CubeGen is essentially a copy with replace function. The input consists of two text files: the model file and the template file. The model file contains the parameters for replacing the labels that have been applied in the template file. The template file contains the source code provided with labels.%0AThe special thing about CubeGen is that the parameters have a hierarchical structure, which you can easily run through recursively.|Functions that are applied In the templates to navigate through the hierarchy of the model elements and then export the selected template segments. In addition to navigation functions, there are functions for replacing the labels in the texts to be exported.|The logical functions are the elements of the logical expressions.;
	=CUBE_GEN_PARAGRAPH[CGP-000000100022]:CMDLINE|Command Line|The program can be run from the command line as a executable or as a Perl script.|cubegen.exe <model> <template> <code> <arguments> %0Aperl cubegen.pl <model> <template> <code> <arguments>%0A-%09<model>: Imported Cube Model textfile%0A-%09<template>: Imported CubeGen Template Textfile%0A-%09<code>: Textfile to generate%0A-%09<parameters>: Arguments that can be referenced in the template;
	=CUBE_GEN_PARAGRAPH[CGP-000000100041]:MDLSTRUC|Cube Model Structure|A Cube model is a hierachical structure of model elements.  An element can be a group of other elements. A group starts with a %22+%22 followed by a tag and ends with %22-%22 followed by the tag. In the case of a separate element the two lines can be merged into one line starting with a %22=%22. A model element can have an idenfier specified between brackets.%0AThe structure can best be explained by an example:|+<tagA>[<identA]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09=<tagB>[<identB]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09+<tagC>[<identC]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09%09=<tagD>[<identD]:<prop0>%7C<prop1>%7C..%7CpropN%3B%0A%09-<tagC>:%3B%0A-<tagA>:%3B;
	=CUBE_GEN_PARAGRAPH[CGP-000000100060]:RGUIDE|Reading Guide|In the first part the functions are explained with examples. The input and output of CubeGen have a background color that match the arrows in the above logo. When the content of a Model or Template is changed, the concernded Code is regenerated by pressing the CubeGen button.%0AInternet Explorer users have to take the following into account:%0A-%09A new line in the Model or Template has to be added with shift-Enter.%0A-%09When the code is regenerated the tab characters are presented as a single space.%0AThe second part contains an overview of the template functions and the logical functions.%0A|#;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100022]:CASE1|First Impression||A simple example with a small model is used to give a first impression of the functionality of CubeGen.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100060]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100027]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100028]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100024]:LOOP1|Iteration Stack|The LOOP statement walks through the model elements for the specified type. For each nested LOOP a model element is placed on the stack.|This is a list of the Busines Object Types:[[LOOP,BUSINESS_OBJECT_TYPE]]%0A-%09<<BUSINESS_OBJECT_TYPE:U>>[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100060]:SELECT1|Selection|The IF, ELSIF, ELSE structure makes a choice between texts based on conditions (logical_expressions).|Explain selection:[[LOOP,BUSINESS_OBJECT_TYPE]][[IF:0=CUSTOMER]]%0A<<BUSINESS_OBJECT_TYPE>> concerns customers.[[ELSIF:0=ORDER]]%0A<<BUSINESS_OBJECT_TYPE>> concerns no customers but orders.[[ELSE]]%0A<<BUSINESS_OBJECT_TYPE>> concerns something else.[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100025]:REPL1|Replacement|Replace a label with the model value. By default, a label refers to the value of the first property of the model element. A number behind the tag refers to the other properties. For example, %221%22 refers to the next following property, so the second one.|[[LOOP,BUSINESS_OBJECT_TYPE]]Unchanged: <<BUSINESS_OBJECT_TYPE>>, <<BUSINESS_OBJECT_TYPE2>>%0AUppercase: <<BUSINESS_OBJECT_TYPE:U>>, <<BUSINESS_OBJECT_TYPE2:U>>%0ALowercase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE2:L>>%0ACamelcase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE2:C>>%0A%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE1;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100040]:CASE2|Introduction Recursivity|TYPE|A first impression of going through a hierarchy in a recursive way.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100040]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100040]:REPEAT1|Repeating Iteration|On the location of the REPEAT statement the loop has been repeated for all underlying elements of the same type.|[[LOOP,BUSINESS_OBJECT_TYPE]]Structure of <<BUSINESS_OBJECT_TYPE:C>>:[[LOOP,TYPE]]%0A-%09<<TYPE:C>>[[REPEAT:TAB]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100246]:REPEAT2|Stack Locations|For each nested LOOP a model element is placed on the stack. By default, reference is made to the last model element placed on the stack. By means of a tag and location, reference can be made to every model element on the stack.%0ALocation %221%22 refers to the first model element that is placed on the stack for the relevant tag. Location %22N%22 shows the most recent. A calculation can refer to an intermediate model element. For example, location %22N-1%22 refers to the second to last.|[[LOOP,BUSINESS_OBJECT_TYPE]]Structure of <<BUSINESS_OBJECT_TYPE:C>>:[[LOOP,TYPE]]%0A-%09<<TYPE:C>> R=<<TYPE(1):C>>[[IF:!ROOT]] P=<<TYPE(N-1):C>> L2=<<TYPE(2):C>>[[ENDIF]][[REPEAT:TAB]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE2;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100101]:CASE10|Model References|TYPE REFERENCE|A model element can also have references to other model elements. These model lines start with %22>%22 and have an alias followed by the identifier of the target model element.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100123]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100124]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100125]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100142]:LOOPREF1|Reference Processing|The LOOP statement also processes the references as they are model elements.|List of References:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]]%0A<<TYPE:C>> <<REFERENCE:C>> <<REFERENCE_TYPE:C>>[[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100143]:LOOPPAR1|Parent Processing|With a %22^%22 in front of the tag, the LOOP statement also processes the parents as they are chiild model elements.|List of References with parent:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]]%0A<<TYPE:C>> <<REFERENCE:C>> <<REFERENCE_TYPE:C>> (<<REFERENCE_TYPE1:U>>)[[LOOP,^BUSINESS_OBJECT_TYPE]]%0A-%09Business Object Type: <<^BUSINESS_OBJECT_TYPE:C>> (<<^BUSINESS_OBJECT_TYPE2:C>>)[[ENDLOOP,^BUSINESS_OBJECT_TYPE]][[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100200]:LOOPINV1|Inversion Processing|With a %22*%22 in front of the tag, the LOOP statement processes the referenes in the inversed direction.|List of referenced types:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[LOOP,*REFERENCE]]%0A<<TYPE:C>> is referenced by [[LOOP,^TYPE]]<<^TYPE:C>>[[ENDLOOP,^TYPE]] with reference <<REFERENCE:C>>[[ENDLOOP,*REFERENCE]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE10;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100120]:CASE20|Logical Expressions|TYPE|Logical expressions are used in the LOOP, IF, CHILD and PARENT functions. A logical expression consists of one logical function or one or more logical operators that combine logical functions.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100140]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100141]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100142]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100143]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100100;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100243]:LOGIC0|Logical Operators|The logical operators are acting on the results of logical expressions. The precedence order of execution is first the NOT, then the AND, and finally the OR.  |Show the precedence of the logical operators:[[LOOP,BUSINESS_OBJECT_TYPE:1=EXT]]%0A True OR False  AND False = [[IF:1=EXT[OR]1=INT[AND]1=INT]]True[[ELSE]]False[[ENDIF]]%0A(True OR False) AND False = [[IF:(1=EXT[OR]1=INT)[AND]1=INT]]True[[ELSE]]False[[ENDIF]]%0A False OR NOT True AND False  = [[IF:1=INT[OR]!1=EXT[AND]1=INT]]True[[ELSE]]False[[ENDIF]]%0A False OR NOT(True AND False) = [[IF:1=INT[OR]!(1=EXT[AND]1=INT)]]True[[ELSE]]False[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100244]:LOGIC3|Qualifier|A qualifier for a logical function can refer to a specific model element on the LOOP stack. This qualifier consists of a tag, possibly followed by a location on the stack. The dafault location is %22N%22, which is a reference to the last model element placed on the stack.|[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[IF:BUSINESS_OBJECT_TYPE.1=INT[AND]TYPE(1).2=Y]]%0A<<TYPE:C>>[[ENDIF]][[IF,TYPE(1):BUSINESS_OBJECT_TYPE.1=INT[AND]2=Y]]%0A<<TYPE:C>>[[ENDIF]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100240]:LOGIC1|First and Last|The FIRST and LAST logical functions are referring to the first and last selected model element.|[[LOOP,BUSINESS_OBJECT_TYPE:1=INT]][[IF:FIRST]]Internal Objects: [[ENDIF]]<<BUSINESS_OBJECT_TYPE:C>>[[IF:!LAST]], [[ELSE]]%3B%0A[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE:1=EXT]][[IF:FIRST]]External Objects: [[ENDIF]]<<BUSINESS_OBJECT_TYPE:C>>[[IF:!LAST]], [[ELSE]]%3B%0A[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE:1=INV]][[IF:FIRST]]Invalid Objects: [[ENDIF]]<<BUSINESS_OBJECT_TYPE:C>>[[IF:!LAST]], [[ELSE]]%3B%0A[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100241]:LOGIC2|Parent and Child|The PARENT and CHILD logical functions are referring to relative locations in the hierarchy.|Type list:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]%0A[[IF:PARENT(BUSINESS_OBJECT_TYPE:1=EXT)]]External[[ELSE]]Internal[[ENDIF]] <<TYPE:C>>[[IF:CHILD(TYPE)]]%0A- has child[[ENDIF]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]]%0A%0AList of internal objects with a child:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE:PARENT(BUSINESS_OBJECT_TYPE:1=INT)[AND]CHILD(TYPE)]]%0A- <<TYPE:C>>[[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE20;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100080]:CASE30|Hierarchy Navigation|TYPE|Navigate through a hierarchy of model elements of one type selected in the active LOOP functions. For a better understanding of the examples, a coding is used for the tags of model elements.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100100]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100060;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100101]:FORV1|Vertical navigation|In the hierarchy selected by LOOP functions, the FORV function navigates top down (vertical) through the model elements. The template segments for the selected model elements will be exported in the order of the loop specification. The loop specification consists of two locations separated by a %22>%22 as arrow and specifies which model elements are run through on the stack. Location references that fall outside the range are skipped.%0AWith the FORV function, the %22V%22 has been added for specifying the location. Next to the %22N%22 referring to the last placed on the stack, the %22V%22 refers to the model element selected in the FORV function. Also the V can be used in the expression.|Parents for all types (with types in between):[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]%0A<<TYPE>>: [[FORV:1>N-1:, ]]<<TYPE>>([[FORV:V+1>N-1:, ]]<<TYPE>>[[ENDFOR]])[[ENDFOR]][[REPEAT]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100100]:FORH1|Horizontal Navigation|In the hierarchy selected by LOOP functions, the FORH function navigates on the same level (horizontal) through the model elements. The template segments for the selected model elements will be exported in the order of the loop specification. For the FORH function, the locations refer to the siblings in the hierarchy.|All types in the hierachy with their left and right siblings:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[REPEAT]][[IF:LAST]][[FORH:1>N]]%0A<<TYPE>> left:[[FORH:V-1>1:,]]<<TYPE>>[[ENDFOR]] right:[[FORH:V+1>N:,]]<<TYPE>>[[ENDFOR]][[ENDFOR]][[ENDIF]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100120]:REPREF1|Replacement References|A replacement label refers to a model element property and can also refer to another model element on the LOOP stack.|All types (with root and parent) with the types in the branch (with parent and child):[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]%0A<<TYPE>>: Root=<<TYPE(1)>> Parent=[[IF:!ROOT]]<<TYPE(N-1)>>[[ENDIF]][[FOR:2>N-1]]%0A-%09<<TYPE>> Parent=<<TYPE(V-1)>> Child=<<TYPE(V+1)>>[[ENDFOR]][[REPEAT]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE30;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100105]:CASE40|Replacement Functions||Manipulate the export of the model element texts or replace the references with model element properties.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100133]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100060;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100130]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100131]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100132]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100182]:REPL4|Manipulate Text|Manipulate the exported text of the model element properties by a function.|[[LOOP,BUSINESS_OBJECT_TYPE:!0=AAA]]Unchanged: <<BUSINESS_OBJECT_TYPE>>, <<BUSINESS_OBJECT_TYPE2>>%0AUppercase: <<BUSINESS_OBJECT_TYPE:U>>, <<BUSINESS_OBJECT_TYPE2:U>>%0ALowercase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE2:L>>%0ACamelcase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE2:C>>%0A%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100163]:REPL2|Property Replacements|Export a model property of the model element.|[[LOOP,BUSINESS_OBJECT_TYPE:!0=AAA]]Unique Number  : <<BUSINESS_OBJECT_TYPE:N>>%0ASub Number     : <<BUSINESS_OBJECT_TYPE:S>> (serial number within parent model element)%0AIndex          : <<BUSINESS_OBJECT_TYPE:IX>> (serial number within the LOOP selection)%0ACube Identifier: <<BUSINESS_OBJECT_TYPE:I>>%0A%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100164]:REPL3|Character Escaping|Escape characters in the exported text of the model element properties by a function.|[[LOOP,BUSINESS_OBJECT_TYPE:0=AAA]]Plain text:%0A<<BUSINESS_OBJECT_TYPE2>>%0APercent escapes:%0A<<BUSINESS_OBJECT_TYPE2:P>>%0AHTML escapes (with HTML break):%0A<<BUSINESS_OBJECT_TYPE2:H>>%0AHTML escapes (with linefeed):%0A<<BUSINESS_OBJECT_TYPE2:HE>>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100220]:LOOPRF1|HTML / Percent Encoding|Apply the HTML escape or URI escacpe (Percent escape) functions to the text within the loop, using LOOP_HTML and LOOP_PERC functions.|The result of LOOP also presented In HTML and percentage escaping:%0A[[LOOP,BUSINESS_OBJECT_TYPE:!0=AAA]]<<<BUSINESS_OBJECT_TYPE:C>>/>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]]%0AHTML: %0A[[LOOP_HTML,BUSINESS_OBJECT_TYPE:!0=AAA]]<<<BUSINESS_OBJECT_TYPE:C>>/>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]]%0APERC: %0A[[LOOP_PERC,BUSINESS_OBJECT_TYPE:!0=AAA]]<<<BUSINESS_OBJECT_TYPE:C>>/>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]]%0A;
	-CUBE_GEN_EXAMPLE_MODEL:CASE40;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100140]:CASE45|Reusable Text||;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100160]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100161]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100162]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100163]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100100;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100245]:TEXT0|Text Blocks / Text Labels|Text blocks are defined for reuse of template segments. The text may contain labels that are replaced with arguments that are defined at the place where the text is applied. |[[TEXT,OBJECT_LIST]][[LOOP,BUSINESS_OBJECT_TYPE:1=<<T1>>]][[IF:FIRST]]<<T2>> Objects: [[ENDIF]]<<BUSINESS_OBJECT_TYPE:C>>[[IF:!LAST]], [[ELSE]]%3B%0A[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[ENDTEXT]]%0A[[BODY]]<<TEXT,OBJECT_LIST[%7C]INT[%7C]Internal[%7C]>><<TEXT,OBJECT_LIST[%7C]EXT[%7C]External[%7C]>><<TEXT,OBJECT_LIST[%7C]INV[%7C]Invalid[%7C]>>[[ENDBODY]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE45;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100103]:CASE50|External Functions||Perl expressions can be used for special functionality that is not available as standard CubeGen functions.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100126]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100128]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100127]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100160]:PERL1|Perl Expressions|The DECL and EVAL functions are performing the Perl eval statement. Only the EVAL function (not the logical expression) exports te result to the code. This can be suppressed by putting the Perl expression between parentheses.|Total length (bits) of the names:[[DECL:sub myLen{return 8*length(@_[0])}]][[LOOP,BUSINESS_OBJECT_TYPE]]%0A[[IF:EVAL:myLen('<<BUSINESS_OBJECT_TYPE>>')<48]]Next with one additional byte.%0A[[EVAL:($myC+=8)]][[ENDIF]]<<BUSINESS_OBJECT_TYPE>>: [[EVAL:$myC+=myLen('<<BUSINESS_OBJECT_TYPE>>')]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE50;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100104]:CASE60|Sequential Processing|TYPE ATTRIBUTE|Export the model elements in the order as they appaer in de Cube model.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100129]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100162]:SEQU1|Sequential Iterations|The model elements referenced by the LOOP functions nested in the SEQUENCE function are exported in the order as they appear in the Cube model.|[[LOOP,BUSINESS_OBJECT_TYPE]]Structure of <<BUSINESS_OBJECT_TYPE:C>>:[[SEQUENCE]][[LOOP,ATTRIBUTE]]%0A-%09Attribute: <<ATTRIBUTE:C>>[[ENDLOOP,ATTRIBUTE]][[LOOP,TYPE]]%0A-%09Type: <<TYPE:C>>[[REPEAT:TAB]][[ENDLOOP,TYPE]][[ENDSEQUENCE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE60;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100061]:CASE90|Model Enhancement|TYPE ATTRIBUTE REFERENCE|The CUBE development framework has steps in which a cube model is copied with a number of enhancements. CubeGen has functions especially for supporting these steps.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100083]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100084]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100085]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100081]:WILDCARD|Wildcard|Instead of a tag, an %22*%22 can be used to apply a template function for all model elements.%0AThe VALUE function is used to copy a specified number of model element values.|! Copied model[[LOOP,*]]%0A+<<*TAG>>[[IF:!ID()]][<<*:I>>][[ENDIF]]:[[VALUE,*:0>N:%7C]]%3B[[REPEAT:TAB]][[LOOP,>*]]%0A%09><<*TAG>>:<<*:I>>%3B[[ENDLOOP,>*]]%0A-<<*TAG>>:%3B[[ENDLOOP,*]];
		=CUBE_GEN_FUNCTION[CGF-000000100082]:ENHANCE|Enhance Model|In the generic model copy function texts can be added as specific enhancements. The TAG logical function has been added to select the concerning model elements.|! Model enhanced with foreign keys[[LOOP,*]]%0A+<<*TAG>>[[IF:!ID()]][<<*:I>>][[ENDIF]]:[[VALUE,*:0>N:%7C]]%3B[[IF:TAG(TYPE)]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]][[LOOP,ATTRIBUTE:1=Y]]%0A%09=FOREIGN_KEY:FK_<<REFERENCE_TYPE1>>_<<ATTRIBUTE>>%7C<<REFERENCE1>>%3B[[ENDLOOP,ATTRIBUTE]][[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[ENDIF]][[REPEAT:TAB]][[LOOP,>*]]%0A%09><<*TAG>>:<<*:I>>%3B[[ENDLOOP,>*]]%0A-<<*TAG>>:%3B[[ENDLOOP,*]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE90;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100151]:AND|Y|Perform the logical AND function on the results of two logical expressions.|<logical_expression>[AND]<logical_expression>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100157]:BODY|N|The BODY function selects the part of the template file or include file that is being exported. Only one BODY function can be applied per file. If the file contains no BODY function, the entire file is exported.|... [[BODY]] ... [[ENDBODY]] ... ;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100147]:CHILD|Y|Check that the current model element for the concerned tag has a child model element with the specified tag (or all for *) that meets (optionally) the specified logical expression. |CHILD(<tag>)%0ACHILD(*)%0ACHILD(<tag>:<logical_expression>)%0A<tag>.CHILD(~~~)%0A<tag>(<location>).CHILD(~~~);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100102]:DECL|N|Perform the Perl eval expression once to decclare in functions or variables. To prefix the names with %22my%22, they will not mixed up to the CubeGen code.|[[DECL:<perl_expression>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100100]:EVAL|N|Export the result of a Perl exprssion. When the Perl expression is placed between parentheses, the result is not exported. To prefix the names with %22my%22, they will not mixed up to the CubeGen code.%0AThe <perl_expression> can contain labels that will be replaced by model element property values.|[[EVAL:<perl_expression>]]%0A[[EVAL:(<perl_expression>)]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100101]:EVAL|Y|Perform a logical Perl expression.%0AThe <perl logicsal expression> can contain labels that will be replaced by a model element property value.|EVAL:<perl_logical_expression>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100156]:FILE|N|The FILE function switches over to another code file during the generation process. The <file_name> can also contain a path reference and labels that will be replaced by a model element property value or parameter value.|[[FILE,<file_name>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100140]:FIRST|Y|Check that it is the first selected model element in the LOOP for the concerned tag. |FIRST%0A<tag>.FIRST%0A<tag>(<location>).FIRST;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100060]:FOR|N|Equal to FORV.|;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100040]:FORH|N|In the hierarchy selected by LOOP functions, the FORH function navigates on the same level (horizontal) through the model elements of the specified or actual type. The template segments for the selected model elements will be exported in the order of the loop specification, possibly separated by a specified string|[[FORH:<loopspec>]] ... [[ENDFOR]]%0A[[FORH,<tag>:<loopspec>]] ... [[ENDFOR]]%0A[[FORH:<loopspec>:<seperator>]] ... [[ENDFOR]]%0A[[FORH,<tag>:<loopspec>:<seperator>]] ... [[ENDFOR]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100041]:FORV|N|In the hierarchy selected by LOOP functions, the FORV function navigates top down (vertical) through the model elements of the specified or actual type. The template segments for the selected model elements will be exported in the order of the loop specification, possibly separated by a specified string.%0A|[[FORV:<loopspec>]] ... [[ENDFOR]]%0A[[FORV,<tag>:<loopspec>]] ... [[ENDFOR]]%0A[[FORV:<loopspec>:<seperator>]] ... [[ENDFOR]]%0A[[FORV,<tag>:<loopspec>:<seperator>]] ... [[ENDFOR]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100149]:ID|Y|Check for the id of the actual model element.%0AThe <value> can contain labels that will be replaced by a model element property value.|ID(<value>)%0A<tag>.ID(<value>)%0A<tag>(<location>).ID(<value>);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100000]:IF|N|Export a template segment that applies to a condition (logical_expression). By default, the logical functions in the logical expression work on the model elements that are selected within the valid loop. If a tag for the colon is filled, the model elements of this tag are used by default. This tag can be overruled by a tag that can be defined for the logical function.|[[IF:<(logical_expression>]] ... [[ENDIF]]%0A[[IF,<tag>:<(logical_expression>]] ... [[ENDIF]]%0A[[IF,<tag>(<location>):<(logical_expression>]] ... [[ENDIF]]%0A[[IF~~~]] ... [[ELSIF~~~]] ... [[ELSE]] ... [[ENDIF]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100155]:INCLUDE|N|Template segments can be included from another file. The filename can also contain a path reference.|[[INCLUDE,<<file_name>>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100144]:LAST|Y|Check that it is the last selected model element in the LOOP for the concerned tag. |LAST%0A<tag>.LAST%0A<tag>(<location>).LAST;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100146]:LEVEL|Y|Check that the model element is of the specified level in the hierachy of the REPEAT LOOP for the concerned tag. So LEVEL(1) checks for the root model element.|LEVEL(<repeat_level>)%0A<tag>.LEVEL(<repeat_level>)%0A<tag>(<location>).LEVEL(<repeat_level>);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100001]:LOOP|N|Export the template segment for the model elements that (optionally) meet the logical expression for the specified tag in sequential order .|[[LOOP,<tag>]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>:<(logical_expression>]] ... [[ENDLOOP,<tag>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100150]:NOT|Y|Invert the result of a logical expression.|!<logical_expression>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100152]:OR|Y|Perform the logical OR function on the results of two logical expressions.|<logical_expression>[OR]<logical_expression>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100148]:PARENT|Y|Check that the current model element for the concerned tag has a parent model element with the specified tag that meets (optionally) the specified logical expression. |PARENT(<tag>)%0APARENT(<tag>:<logical_expression>)%0A<tag>.PARENT(~~~)%0A<tag>(<location>).PARENT(~~~);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100002]:REPEAT|N|Repeat the LOOP function for all underlying model elements of the specified type. The indentation of the exported text can be increased by one or more tabs. (eg. TAB, 2TAB, 3TAB, ...)|[[LOOP,<tag>]] ... [[REPEAT]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>]] ... [[REPEAT:nTAB]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>]] ... [[LOOP...]] ... [[REPEAT,<tag>]] ... [[ENDLOOP...]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>]] ... [[LOOP...]] ... [[REPEAT,<tag>:nTAB]] ... [[ENDLOOP...]] ... [[ENDLOOP,<tag>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100145]:ROOT|Y|Check that the model element is the root of the hierachy of the REPEAT LOOP for the concerned tag. |ROOT%0A<tag>.ROOT%0A<tag>(<location>).ROOT;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100108]:SEQUENCE|N|The model elements referenced by the LOOP functions nested in the SEQUENCE function are exported in the order as they appear in the Cube model. The text within the SEQUENCE function and outside the nested LOOP function is ignored, and will not be exported. |[[SEQUENCE]]%0A[[LOOP,<tag1>]] ... [[ENDLOOP,<tag1>]]%0A[[LOOP,<tag2>]] ... [[ENDLOOP,<tag2>]]%0A...%0A[[LOOP,<tagN>]] ... [[ENDLOOP,<tagN>]]%0A[[ENDSEQUENCE]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100160]:TABS|N|Increase or decrease indentation of the current and following text segments. To decrease indentation specify a negative increment.|[[TABS:<increment>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100020]:TAG|Y|Check for the type of the actual model element.|TAG(<tag>);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100123]:TEMPLATE|N|Process a model element property as a template segment.|[[TEMPLATE:<tag>]]%0A[[TEMPLATE:<tag>(<location>)]]%0A[[TEMPLATE:<tag>(<location>)<property>]]%0A[[TEMPLATE:<tag>:<function>]]%0A[[TEMPLATE:<tag>(<location>):<function>]]%0A[[TEMPLATE:<tag>(<location>)<property>:<function>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100154]:TEXT|N|Text blocks are defined for reuse of template segments. The text may contain labels that are replaced with arguments that are defined at the place where the text is applied. The optional list of arguments starts and ends with the separator %22[%7C]%22. The text is only exported at the location of the text labels. The text blocks themselves are not exported.%0AThe indentation of the exported text can be increased by one or more tabs. (eg. TAB, 2TAB, 3TAB, ...)|[[TEXT,<name>]] ... [[ENDTEXT]]%0A<<TEXT,<name>>>%0A<<TEXT:nTAB,<name>>>%0A%0A[[TEXT,<name>]] ... <<T1>> ... <<T2>> ... [[ENDTEXT]]%0A<<TEXT,<name>[%7C]<parm1>[%7C]<parm2>[%7C]>>%0A<<TEXT:nTAB,<name>[%7C]<parm1>[%7C]<parm2>[%7C]>>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100003]:VALUE|N|Export the properties of a model element.|[[VALUE,<tag>:<loop_spec>:<separator>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100106]:comment|N|Text that is not exported.|[[* ... *]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100142]:parameter=|Y|The parameters specified on the command line can be referenced in the %22is equal to%22 logical expression.%0AThe <value> can contain labels that will be replaced by a model element property value or parameter value.|P<parm_number>=<value>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100120]:parameters|N|The parameters specified on the command line can be selected for export. Only the replace functions L (lowercase) and U (uppercase) are supported.|<<<parm_number>>>%0A<<<parm_number>:<function>>>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100153]:parentheses|Y|Parentheses are used in the logical expressions to define the precedence of the AND,OR and NOT operations.|!(<logical_expression>[AND](<logical_expression>[OR]<logical_expression>));
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100143]:property=|Y|A model element property can be referenced in the %22is equal to%22 logical expression.%0AThe <value> can contain labels that will be replaced by a model element property value or parameter value.|<property_number>=<value>%0A<tag>.<property_number>=<value>%0A<tag>(<location>).<property_number>=<value>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100107]:replacement|N|Replace a label with a model value.|<<<tag>>>%0A<<<tag>(<location>)>>%0A<<<tag><property>>>%0A<<<tag>(<location>)<property>>>%0A<<<tag>:<function>>>%0A<<<tag>(<location>):<function>>>%0A<<<tag><property>:<function>>>%0A<<<tag>(<location>)<property>:<function>>>%0A;
-CUBE_GEN_DOCUMENTATION:Cube_Gen_Manual;
