! Generated with CubeGen
+META_MODEL:CUBE;
	+META_TYPE:INFORMATION_TYPE|;
		=PROPERTY:0|Name|;
		+META_TYPE:INFORMATION_TYPE_ELEMENT|;
			=PROPERTY:0|Sequence|;
			=PROPERTY:1|Suffix|;
			=PROPERTY:2|Domain| Values: CH(Text), NR(Number), DT(Date), TI(Time), TS(Timestamp);
			=PROPERTY:3|Length|;
			=PROPERTY:4|Decimals|;
			=PROPERTY:5|CaseSensitive| Values: Y(Yes), N(No);
			=PROPERTY:6|DefaultValue|;
			=PROPERTY:7|SpacesAllowed| Values: Y(Yes), N(No);
			=PROPERTY:8|Presentation|Indication how the string is presented in the user dialog. Values: LIN(Line), DES(Description), COD(Code);
			+META_TYPE:PERMITTED_VALUE|;
				=PROPERTY:0|Code|;
				=PROPERTY:1|Prompt|;
			-META_TYPE:PERMITTED_VALUE;
		-META_TYPE:INFORMATION_TYPE_ELEMENT;
	-META_TYPE:INFORMATION_TYPE;
	+META_TYPE:BUSINESS_OBJECT_TYPE|An object type related to the business supported by the system.;
		=PROPERTY:0|Name|;
		=PROPERTY:1|Directory|;
		+META_TYPE:TYPE|An entity type related to the business that is supported by the system.;
			=PROPERTY:0|Name|;
			=PROPERTY:1|Code|;
			=PROPERTY:2|FlagPartialKey| Values: Y(Yes), N(No);
			=PROPERTY:3|FlagRecursive| Values: Y(Yes), N(No);
			=PROPERTY:4|RecursiveCardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
			=PROPERTY:5|Cardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
			=PROPERTY:6|SortOrder| Values: N(No sort), K(Key), P(Position);
			=PROPERTY:7|Icon|;
			=PROPERTY:8|Transferable|Indication that in case of a recursive type the type may moved to an other parent in the hierarchy. Values: Y(Yes), N(No);
			+META_TYPE:ATTRIBUTE|;
				=PROPERTY:0|Name|Unique identifier of the attribute.;
				=PROPERTY:1|PrimaryKey|Indication that attribute is part of the unique identification of the type. Values: Y(Yes), N(No);
				=PROPERTY:2|CodeDisplayKey| Values: Y(Yes), S(Sub), N(No);
				=PROPERTY:3|CodeForeignKey| Values: N(None);
				=PROPERTY:4|FlagHidden| Values: Y(Yes), N(No);
				=PROPERTY:5|DefaultValue|Defaut value that overules the default value specified by the information type element.;
				=PROPERTY:6|Unchangeable|Indication that after the creation of the type the value of the atrribute can not be changed. Values: Y(Yes), N(No);
				=ASSOCIATION:INFORMATION_TYPE|HasDomain|INFORMATION_TYPE|;
				+META_TYPE:DERIVATION|;
					=PROPERTY:0|CubeTsgType| Values: DN(DENORMALIZATION), IN(INTERNAL), AG(AGGREGATION);
					=PROPERTY:1|AggregateFunction| Values: SUM(Sum), AVG(Average), MIN(Minimum), MAX(Maximum);
					=ASSOCIATION:DERIVATION_TYPE|ConcernsParent|TYPE|;
					=ASSOCIATION:DERIVATION_TYPE_CONCERNS_CHILD|ConcernsChild|TYPE|;
				-META_TYPE:DERIVATION;
				+META_TYPE:DESCRIPTION_ATTRIBUTE|;
					=PROPERTY:0|Text|;
				-META_TYPE:DESCRIPTION_ATTRIBUTE;
				+META_TYPE:RESTRICTION_TYPE_SPEC_ATB|;
					=PROPERTY:0|IncludeOrExclude|Indication that the attribute is valid (included) or invalid (excluded) for the concerning type specialisation. Values: IN(Include), EX(Exclude);
					=ASSOCIATION:TYPE_SPECIALISATION|IsValidFor|TYPE_SPECIALISATION|;
				-META_TYPE:RESTRICTION_TYPE_SPEC_ATB;
			-META_TYPE:ATTRIBUTE;
			+META_TYPE:REFERENCE|;
				=PROPERTY:0|Name|;
				=PROPERTY:1|PrimaryKey|Indication that reference is part of the unique identification of the type. Values: Y(Yes), N(No);
				=PROPERTY:2|CodeDisplayKey| Values: Y(Yes), S(Sub), N(No);
				=PROPERTY:3|Sequence|;
				=PROPERTY:4|Scope|In case of a recursive target%2C the definition of the collection of the types to select. Values: ALL(All), ENC(Encapsulated), PRA(Parents all), PR1(Parents first level), CHA(Children all), CH1(Children first level);
				=PROPERTY:5|Unchangeable|Indication that after the creation of the type the reference can not be changed. So in case of a recursive reference the indication too that the relation is used to select the parents or children in the hierarchy. Values: Y(Yes), N(No);
				=PROPERTY:6|WithinScopeLevel|In case of recursive %22wihin scope of%22 type the relative level in the hierarchy%2C Positive numbers are the parent levels%2C Negative numbers are the child levels.;
				=ASSOCIATION:REFERENCE_TYPE|Refer|TYPE|The target entity type of the reference.;
				=ASSOCIATION:REFERENCE_TYPE_WITHIN_SCOPE_OF|WithinScopeOf|TYPE|In case of non recursive target or a scope all recursive target the common type for the selection.;
				+META_TYPE:DESCRIPTION_REFERENCE|;
					=PROPERTY:0|Text|;
				-META_TYPE:DESCRIPTION_REFERENCE;
				+META_TYPE:RESTRICTION_TYPE_SPEC_REF|;
					=PROPERTY:0|IncludeOrExclude|Indication that the reference is valid (included) or invalid (excluded) for the concerning type specialisation. Values: IN(Include), EX(Exclude);
					=ASSOCIATION:TYPE_SPECIALISATION|IsValidFor|TYPE_SPECIALISATION|;
				-META_TYPE:RESTRICTION_TYPE_SPEC_REF;
			-META_TYPE:REFERENCE;
			+META_TYPE:TYPE_REUSE|;
				=PROPERTY:0|Cardinality| Values: 1(1), 2(2), 3(3), 4(4), 5(5), N(Many);
				=ASSOCIATION:TYPE_REUSE_TYPE|Refer|TYPE|;
			-META_TYPE:TYPE_REUSE;
			+META_TYPE:PARTITION|;
				=PROPERTY:0|Name|;
				+META_TYPE:SUBTYPE|;
					=PROPERTY:0|Name|;
				-META_TYPE:SUBTYPE;
			-META_TYPE:PARTITION;
			+META_TYPE:TYPE_SPECIALISATION_GROUP|;
				=PROPERTY:0|Code|;
				=PROPERTY:1|Name|;
				=PROPERTY:2|PrimaryKey|Indication that the type specification group is part of the unique identification of the type. Values: Y(Yes), N(No);
				+META_TYPE:TYPE_SPECIALISATION|;
					=PROPERTY:0|Code|;
					=PROPERTY:1|Name|;
					=ASSOCIATION:TYPE_SPECIALISATION|Specialise|TYPE_SPECIALISATION|;
				-META_TYPE:TYPE_SPECIALISATION;
			-META_TYPE:TYPE_SPECIALISATION_GROUP;
			+META_TYPE:DESCRIPTION_TYPE|Test%0D%0AMet LF en %22 en %27  en %25    %25%0D%0AEInde;
				=PROPERTY:0|Text|;
			-META_TYPE:DESCRIPTION_TYPE;
		-META_TYPE:TYPE;
	-META_TYPE:BUSINESS_OBJECT_TYPE;
	+META_TYPE:SYSTEM|;
		=PROPERTY:0|Name|;
		=PROPERTY:1|Database|;
		=PROPERTY:2|Schema|;
		=PROPERTY:3|Password|;
		+META_TYPE:SYSTEM_BO_TYPE|;
			=ASSOCIATION:BUSINESS_OBJECT_TYPE|Has|BUSINESS_OBJECT_TYPE|;
		-META_TYPE:SYSTEM_BO_TYPE;
	-META_TYPE:SYSTEM;
	+META_TYPE:CUBE_GEN_DOCUMENTATION|A document to give an explanation of CubeGen based on examples.;
		=PROPERTY:0|Name|The name of the document.;
		=PROPERTY:1|Description|;
		=PROPERTY:2|DescriptionFunctions|Description for Template Function chapter.;
		+META_TYPE:CUBE_GEN_PARAGRAPH|;
			=PROPERTY:0|Id|Technical identifier.;
			=PROPERTY:1|Header|Text used as header and used in the index.;
			=PROPERTY:2|Description|;
			=PROPERTY:3|Example|An example to explain the paragraph. No example is indicated by a %27%23%27.;
		-META_TYPE:CUBE_GEN_PARAGRAPH;
		+META_TYPE:CUBE_GEN_EXAMPLE_MODEL|A view on the business object model with examples of functions based on the business object model.;
			=PROPERTY:0|Id|Technical identifier.;
			=PROPERTY:1|Header|Text used as header and used in the index.;
			=PROPERTY:2|IncludedObjectNames|The names of types that are included in the view of the business object model.;
			=PROPERTY:3|Description|;
			+META_TYPE:CUBE_GEN_EXAMPLE_OBJECT|A reference to a business object that is used in the examples.;
				=ASSOCIATION:BUSINESS_OBJECT_TYPE|UsesAsExample|BUSINESS_OBJECT_TYPE|;
			-META_TYPE:CUBE_GEN_EXAMPLE_OBJECT;
			+META_TYPE:CUBE_GEN_FUNCTION|A CubeGen function that has been explained with a template.;
				=PROPERTY:0|Id|Technical identifier.;
				=PROPERTY:1|Header|Text used as header and used in the index.;
				=PROPERTY:2|Description|;
				=PROPERTY:3|Template|CubeGen template used as example.;
			-META_TYPE:CUBE_GEN_FUNCTION;
		-META_TYPE:CUBE_GEN_EXAMPLE_MODEL;
		+META_TYPE:CUBE_GEN_TEMPLATE_FUNCTION|;
			=PROPERTY:0|Name|;
			=PROPERTY:1|IndicationLogical|Indication that the function is a locical expression used in a condition. Values: Y(Yes), N(No);
			=PROPERTY:2|Description|;
			=PROPERTY:3|Syntax|;
		-META_TYPE:CUBE_GEN_TEMPLATE_FUNCTION;
	-META_TYPE:CUBE_GEN_DOCUMENTATION;
-META_MODEL:CUBE;
+BUSINESS_OBJECT_TYPE[BOT-000000100040]:CUSTOMER|customer_files;
	+TYPE[TYP-000000100021]:CUSTOMER|CUS|N|N|N|N|N||Y;
		+ATTRIBUTE[ATB-000000100004]:RELATION_NUMBER|Y|Y|N|N||N;
		-ATTRIBUTE:RELATION_NUMBER;
		+ATTRIBUTE[ATB-000000100001]:NAME|N|N|N|N||N;
		-ATTRIBUTE:NAME;
	-TYPE:CUSTOMER;
-BUSINESS_OBJECT_TYPE:CUSTOMER;
+BUSINESS_OBJECT_TYPE[BOT-000000100024]:ORDER|order_directory;
	+TYPE[TYP-000000100020]:ORDER|ORD|N|N|N|N|N||Y;
		+ATTRIBUTE[ATB-000000100005]:NUMBER|N|N|N|N||N;
		-ATTRIBUTE:NUMBER;
		+ATTRIBUTE[ATB-000000100006]:DELIVERY_DATE|N|N|N|N||N;
		-ATTRIBUTE:DELIVERY_DATE;
		+ATTRIBUTE[ATB-000000100003]:DESCRIPTION|N|N|N|N||N;
		-ATTRIBUTE:DESCRIPTION;
		+REFERENCE[REF-000000100000]:IS_PLACED_BY|N|N|0|ALL|N|0;
			>REFERENCE_TYPE:TYP-000000100021;
		-REFERENCE:IS_PLACED_BY;
		+TYPE[TYP-000000100022]:ORDER_LINE|ORL|Y|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100020]:NUMBER|Y|N|N|N||N;
			-ATTRIBUTE:NUMBER;
			+ATTRIBUTE[ATB-000000100021]:DESCRIPTION|N|N|N|N||N;
			-ATTRIBUTE:DESCRIPTION;
			+REFERENCE[REF-000000100001]:CONCERNS|Y|Y|0|ALL|N|0;
				>REFERENCE_TYPE:TYP-000000100000;
			-REFERENCE:CONCERNS;
		-TYPE:ORDER_LINE;
	-TYPE:ORDER;
-BUSINESS_OBJECT_TYPE:ORDER;
+BUSINESS_OBJECT_TYPE[BOT-000000100025]:PRODUCT|product_definitions;
	+TYPE[TYP-000000100000]:PRODUCT|PRD|Y|N|N|N|N|PRODUCT|Y;
		+ATTRIBUTE[ATB-000000100007]:CODE|Y|Y|N|N||N;
		-ATTRIBUTE:CODE;
		+TYPE[TYP-000000100004]:PRODUCT_PART_APPLICATION|PPA|Y|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100008]:CODE|Y|N|N|N||N;
			-ATTRIBUTE:CODE;
			+ATTRIBUTE[ATB-000000100010]:COUNT|N|N|N|N||N;
			-ATTRIBUTE:COUNT;
		-TYPE:PRODUCT_PART_APPLICATION;
		+TYPE[TYP-000000100002]:PRODUCTION_PROCES|PPR|N|N|N|N|N||Y;
			+ATTRIBUTE[ATB-000000100012]:PROCES_ID|Y|N|N|N||N;
			-ATTRIBUTE:PROCES_ID;
			+TYPE[TYP-000000100003]:PRODUCTION_PROCES_STEP|PPS|N|N|N|N|N||Y;
				+ATTRIBUTE[ATB-000000100013]:PROCES_STEP_ID|Y|N|N|N||N;
				-ATTRIBUTE:PROCES_STEP_ID;
				+ATTRIBUTE[ATB-000000100014]:DESCRIPTION|N|N|N|N||N;
				-ATTRIBUTE:DESCRIPTION;
			-TYPE:PRODUCTION_PROCES_STEP;
		-TYPE:PRODUCTION_PROCES;
	-TYPE:PRODUCT;
-BUSINESS_OBJECT_TYPE:PRODUCT;
+BUSINESS_OBJECT_TYPE[BOT-000000100060]:AAA|<b>AAA</b><br>test.;
	+TYPE[TYP-000000100040]:AAA|AAA|N|N|N|N|N||Y;
		+TYPE[TYP-000000100041]:BBB1|BB1|N|N|N|N|N||Y;
			+TYPE[TYP-000000100048]:CCC11|C11|N|N|N|N|N||Y;
				+TYPE[TYP-000000100057]:DDD111|D01|N|N|N|N|N||Y;
				-TYPE:DDD111;
			-TYPE:CCC11;
			+TYPE[TYP-000000100049]:CCC12|C12|N|N|N|N|N||Y;
				+TYPE[TYP-000000100063]:DDD121|D11|N|N|N|N|N||Y;
				-TYPE:DDD121;
				+TYPE[TYP-000000100062]:DDD122|D12|N|N|N|N|N||Y;
				-TYPE:DDD122;
			-TYPE:CCC12;
			+TYPE[TYP-000000100050]:CCC13|C13|N|N|N|N|N||Y;
				+TYPE[TYP-000000100064]:DDD131|D21|N|N|N|N|N||Y;
				-TYPE:DDD131;
				+TYPE[TYP-000000100065]:DDD132|D22|N|N|N|N|N||Y;
				-TYPE:DDD132;
				+TYPE[TYP-000000100066]:DDD133|D23|N|N|N|N|N||Y;
				-TYPE:DDD133;
			-TYPE:CCC13;
		-TYPE:BBB1;
		+TYPE[TYP-000000100042]:BBB2|BB2|N|N|N|N|N||Y;
			+TYPE[TYP-000000100051]:CCC21|C21|N|N|N|N|N||Y;
			-TYPE:CCC21;
			+TYPE[TYP-000000100052]:CCC22|C22|N|N|N|N|N||Y;
			-TYPE:CCC22;
			+TYPE[TYP-000000100053]:CCC23|C2|N|N|N|N|N||Y;
			-TYPE:CCC23;
		-TYPE:BBB2;
	-TYPE:AAA;
-BUSINESS_OBJECT_TYPE:AAA;
+CUBE_GEN_DOCUMENTATION[CUB-000000100022]:Cube_Gen_Manual|CubeGen is essentially a copy with replace function. The input consists of two text files: the model file and the template file. The model file contains the parameters for replacing the labels that have been applied in the template file. The template file contains the source code provided with labels.%0AThe special thing about CubeGen is that the parameters have a hierarchical structure, which you can easily run through recursively.|;
	=CUBE_GEN_PARAGRAPH[CGP-000000100022]:CMDLINE|Command Line|The program can be run from the command line as a executable or as a Perl script.|cubegen.exe <model> <template> <code> <arguments> %0Aperl cubegen.pl <model> <template> <code> <arguments>%0A-%09<model>: Imported Cube Model textfile%0A-%09<template>: Imported CubeGen Template Textfile%0A-%09<code>: Textfile to generate%0A-%09<parameters>: Arguments that can be referenced in the template;
	=CUBE_GEN_PARAGRAPH[CGP-000000100041]:MDLSTRUC|Cube Model Structure|A Cube model is a hierachical structure of model elements.  An element can be a group of other elements. A group starts with a %22+%22 followed by a tag and ends with %22-%22 followed by the tag. In the case of a separate element the two lines can be merged into one line starting with a %22=%22. A model element can have an idenfier specified between brackets.%0AThe structure can best be explained by an example:|+<tagA>[<identA]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09=<tagB>[<identB]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09+<tagC>[<identC]:<prop0>%7C<prop1>%7C...%7CpropN%3B%0A%09%09=<tagD>[<identD]:<prop0>%7C<prop1>%7C..%7CpropN%3B%0A%09-<tagC>:%3B%0A-<tagA>:%3B;
	=CUBE_GEN_PARAGRAPH[CGP-000000100060]:RGUIDE|Reading Guide|The functions are explained with examples. The input and output of CubeGen have a background color that match the arrows in the above logo.|#;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100022]:CASE1|First Impression||A simple example with a small model is used to give a first impression of the functionality of CubeGen.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100060]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100027]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100028]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100024]:LOOP1|Iteration|The LOOP statement walks through the model elements for the specified type.|This is a list of the Busines Object Types:[[LOOP,BUSINESS_OBJECT_TYPE]]%0A-%09<<BUSINESS_OBJECT_TYPE:U>>[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100060]:SELECT1|Selection|The IF, ELSIF, ELSE structure makes a choice between texts based on conditions.|Explain selection:[[LOOP,BUSINESS_OBJECT_TYPE]][[IF:0=CUSTOMER]]%0A<<BUSINESS_OBJECT_TYPE>> concerns customers.[[ELSIF:0=ORDER]]%0A<<BUSINESS_OBJECT_TYPE>> concerns no customers but orders.[[ELSE]]%0A<<BUSINESS_OBJECT_TYPE>> concerns something else.[[ENDIF]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100025]:REPL1|Replacement|Replace a label with the model value.|[[LOOP,BUSINESS_OBJECT_TYPE]]Uppercase: <<BUSINESS_OBJECT_TYPE:U>>, <<BUSINESS_OBJECT_TYPE1:U>>%0ALowercase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE1:L>>%0ACamelcase: <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE1:C>>%0A%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE1;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100040]:CASE2|Introduction Recursivity|TYPE|A first impression of going through a hierarchy in a recursive way.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100040]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100040]:REPEAT1|Repeating Iteration|On the location of the REPEAT statement the loop has been repeated for all underlying elements of the same type.|[[LOOP,BUSINESS_OBJECT_TYPE]]Structure of <<BUSINESS_OBJECT_TYPE:C>>:[[LOOP,TYPE]]%0A-%09<<TYPE:C>>[[REPEAT:TAB]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE2;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100101]:CASE10|Cube Model References|TYPE REFERENCE|A model element can also have references to other model elements. These model lines start with %22>%22 and have an alias followed by the identifier of the target model element.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100123]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100124]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100125]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100142]:LOOPREF1|Reference Processing|The LOOP statement also processes the references as they are model elements.|List of References:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]]%0A<<TYPE:C>> <<REFERENCE:C>> <<REFERENCE_TYPE:C>>[[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100143]:LOOPPAR1|Parent Processing|With the %22^%22 in front of the tag, the LOOP statement also processes the parents as they are chiild model elements.|List of References with parent:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]]%0A<<TYPE:C>> <<REFERENCE:C>> <<REFERENCE_TYPE:C>> (<<REFERENCE_TYPE1:U>>)[[LOOP,^BUSINESS_OBJECT_TYPE]]%0A-%09Business Object Type: <<^BUSINESS_OBJECT_TYPE:C>> (<<^BUSINESS_OBJECT_TYPE1:C>>)[[ENDLOOP,^BUSINESS_OBJECT_TYPE]][[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE10;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100080]:CASE30|Hierarchy Navigation|TYPE|Navigate through a hierarchy of model elements of one type selected in the active LOOP functions. For a better understanding of the examples, a coding is used for the tags of model elements.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100100]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100060;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100101]:FORV1|Vertical navigation|In the hierarchy selected by LOOP functions, the FORV function navigates top down (vertical) through the model elements. The template segments for the selected model elements will be exported in the order of the loop specification.|Parents for all types (with types in between):[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]%0A<b><<TYPE>></b>: [[FORV:1>N-1:, ]]<<TYPE>>([[FORV:V+1>N-1:, ]]<<TYPE>>[[ENDFOR]])[[ENDFOR]][[REPEAT]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100100]:FORH1|Horizontal Navigation|In the hierarchy selected by LOOP functions, the FORH function navigates on the same level (horizontal) through the model elements. The template segments for the selected model elements will be exported in the order of the loop specification.|All types in the hierachy with their left and right siblings:[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]][[REPEAT]][[IF:LAST]][[FORH:1>N]]%0A<b><<TYPE>></b> left:[[FORH:V-1>1:,]]<<TYPE>>[[ENDFOR]] right:[[FORH:V+1>N:,]]<<TYPE>>[[ENDFOR]][[ENDFOR]][[ENDIF]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100120]:REPREF1|Replacement References|A replacement can refer to a model element selected by the current LOOP statements.|All types (with root and parent) with the types in the branch (with parent and child):[[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]%0A<b><<TYPE>></b>: Root=<<TYPE(1)>> Parent=[[IF:!ROOT]]<<TYPE(N-1)>>[[ENDIF]][[FOR:2>N-1]]%0A-%09<<TYPE>> Parent=<<TYPE(V-1)>> Child=<<TYPE(V+1)>>[[ENDFOR]][[REPEAT]][[ENDLOOP,TYPE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE30;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100105]:CASE40|Replacement Functions||;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100133]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100060;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100130]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100131]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100132]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100163]:REPL2|Basic Replacements||[[LOOP,BUSINESS_OBJECT_TYPE:!0=AAA]]%0AUppercase       : <<BUSINESS_OBJECT_TYPE:U>>, <<BUSINESS_OBJECT_TYPE1:U>>%0ALowercase       : <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE1:L>>%0ACamelcase       : <<BUSINESS_OBJECT_TYPE:L>>, <<BUSINESS_OBJECT_TYPE1:C>>%0AUnique Number   : <<BUSINESS_OBJECT_TYPE:N>>%0ASub Number      : <<BUSINESS_OBJECT_TYPE:S>> (serial number within parent model element)%0AIndex           : <<BUSINESS_OBJECT_TYPE:IX>> (serial number within the LOOP selection)%0ACube Identifier : <<BUSINESS_OBJECT_TYPE:I>>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
		=CUBE_GEN_FUNCTION[CGF-000000100164]:REPL3|Character Escaping||[[LOOP,BUSINESS_OBJECT_TYPE:0=AAA]]<b><u>Plain text</u></b>%0A<<BUSINESS_OBJECT_TYPE1>>%0A<b><u>Percent escapes</u></b>%0A<<BUSINESS_OBJECT_TYPE1:P>>%0A<b><u>HTML escapes</u></b>%0A<<BUSINESS_OBJECT_TYPE1:H>>%0A<b><u>HTML escapes with EOL</u></b>%0A<<BUSINESS_OBJECT_TYPE1:HE>>%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE40;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100103]:CASE50|External Functions||Perl expressions can be used for special functionality that is not available as standard CubeGen functions.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100126]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100128]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100127]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100160]:PERL1|Perl Expressions|The DECL and EVAL functions are performing the Perl eval statement. Only the EVAL function (not the logical expression) exports te result to the code. This can be suppressed by putting the Perl expression between parentheses.|Total length (bits) of the names:[[DECL:sub myLen{return 8*length(@_[0])}]][[LOOP,BUSINESS_OBJECT_TYPE]]%0A[[IF:EVAL:myLen('<<BUSINESS_OBJECT_TYPE>>')<48]]Next with one additional byte.%0A[[EVAL:($myC+=8)]][[ENDIF]]<<BUSINESS_OBJECT_TYPE>>: [[EVAL:$myC+=myLen('<<BUSINESS_OBJECT_TYPE>>')]][[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE50;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100104]:CASE60|Sequential Processing|TYPE ATTRIBUTE|Export the model elements in the order as they appaer in de Cube model.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100129]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100162]:SEQU1|Sequential Iterations|The model elements referenced by the LOOP functions nested in the SEQUENCE function are exported in the order as they appear in the Cube model.|[[LOOP,BUSINESS_OBJECT_TYPE]]Structure of <<BUSINESS_OBJECT_TYPE:C>>:[[SEQUENCE]][[LOOP,ATTRIBUTE]]%0A-%09Attribute: <<ATTRIBUTE:C>>[[ENDLOOP,ATTRIBUTE]][[LOOP,TYPE]]%0A-%09Type: <<TYPE:C>>[[REPEAT:TAB]][[ENDLOOP,TYPE]][[ENDSEQUENCE]]%0A[[ENDLOOP,BUSINESS_OBJECT_TYPE]];
	-CUBE_GEN_EXAMPLE_MODEL:CASE60;
	+CUBE_GEN_EXAMPLE_MODEL[CGM-000000100061]:CASE90|Model Enhancement|TYPE ATTRIBUTE REFERENCE|The CUBE development framework has steps in which a cube model is copied with a number of enhancements. CubeGen has functions especially for supporting these steps.;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100083]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100040;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100084]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100024;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		+CUBE_GEN_EXAMPLE_OBJECT[CGO-000000100085]:;
			>BUSINESS_OBJECT_TYPE:BOT-000000100025;
		-CUBE_GEN_EXAMPLE_OBJECT:;
		=CUBE_GEN_FUNCTION[CGF-000000100081]:WILDCARD|Wildcard|Instead of a tag, an %22*%22 can be used to apply a template function for all model elements.%0AThe VALUE function is used to copy a specified number of model element values.|! Copied model[[LOOP,*]]%0A+<<*TAG>>[[IF:EVAL:'<<*:I>>'ne'']][<<*:I>>][[ENDIF]]:[[VALUE,*:0>N:%7C]]%3B[[REPEAT:TAB]][[LOOP,>*]]%0A%09><<*TAG>>:<<*:I>>%3B[[ENDLOOP,>*]]%0A-<<*TAG>>:%3B[[ENDLOOP,*]];
		=CUBE_GEN_FUNCTION[CGF-000000100082]:ENHANCE|Enhance Model|In the generic model copy function texts can be added as specific enhancements. The TAG condition has been added to select the concerning model elements.|! Model enhanced with foreign keys[[LOOP,*]]%0A+<<*TAG>>[[IF:EVAL:'<<*:I>>'ne'']][<<*:I>>][[ENDIF]]:[[VALUE,*:0>N:%7C]]%3B[[IF:TAG(TYPE)]][[LOOP,REFERENCE]][[LOOP,REFERENCE_TYPE]][[LOOP,ATTRIBUTE:1=Y]]%0A%09=FOREIGN_KEY:FK_<<REFERENCE_TYPE1>>_<<ATTRIBUTE>>%7C<<REFERENCE1>>%3B[[ENDLOOP,ATTRIBUTE]][[ENDLOOP,REFERENCE_TYPE]][[ENDLOOP,REFERENCE]][[ENDIF]][[REPEAT:TAB]][[LOOP,>*]]%0A%09><<*TAG>>:<<*:I>>%3B[[ENDLOOP,>*]]%0A-<<*TAG>>:%3B[[ENDLOOP,*]];
		=CUBE_GEN_FUNCTION[CGF-000000100161]:COMMENT|||;
	-CUBE_GEN_EXAMPLE_MODEL:CASE90;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100102]:DECL|N|Perform the Perl eval expression once to decclare in functions or variables. To prefix the names with %22my%22, they will not mixed up to the CubeGen code.|[[DECL:<perl_expression>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100100]:EVAL|N|Export the result of a Perl exprssion. When the Perl expression is placed between parentheses, the result is not exported. To prefix the names with %22my%22, they will not mixed up to the CubeGen code.|[[EVAL:<perl_expression>]]%0A[[EVAL:(<perl_expression>)]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100101]:EVAL|Y|Perform a logical Perl expression.|EVAL:<perl_logical_expression>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100060]:FOR|N|Equal to FORV.|;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100040]:FORH|N|In the hierarchy selected by LOOP functions, the FORH function navigates on the same level (horizontal) through the model elements of the specified or actual type. The template segments for the selected model elements will be exported in the order of the loop specification, possibly separated by a specified string|[[FORH:<loopspec>]] ... [[ENDFOR]]%0A[[FORH,<tag>:<loopspec>:<seperator>]] ... [[ENDFOR]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100041]:FORV|N|In the hierarchy selected by LOOP functions, the FORV function navigates top down (vertical) through the model elements of the specified or actual type. The template segments for the selected model elements will be exported in the order of the loop specification, possibly separated by a specified string.%0A|[[FORV:<loopspec>]] ... [[ENDFOR]]%0A[[FORV,<tag>:<loopspec>:<seperator>]] ... [[ENDFOR]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100000]:IF|N|Export a template segment that applies to a condition.|[[IF:<condition>]] ... [[ENDIF]]%0A[[IF,<tag>:<condition>]] ... [[ELSIF,<tag>:<condition>]] ... [[ELSE]] ... [[ENDIF]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100001]:LOOP|N|Export the template segment for the model elements of the specified type in sequential order .|[[LOOP,<tag>]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>:<condition>]] ... [[ENDLOOP,<tag>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100002]:REPEAT|N|Repeat the LOOP function for all underlying model elements of the specified type.|[[LOOP,<tag>]] ... [[REPEAT]] ... [[ENDLOOP,<tag>]]%0A[[LOOP,<tag>]] ... [[LOOP...]] ... [[REPEAT,<tag>:TAB]] ... [[ENDLOOP...]] ... [[ENDLOOP,<tag>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100108]:SEQUENCE|N|The model elements referenced by the LOOP functions nested in the SEQUENCE function are exported in the order as they appear in the Cube model. The text within the SEQUENCE function and outside the nested LOOP function is ignored, and will not be exported. |[[SEQUENCE]]%0A[[LOOP,<tag1>]] ... [[ENDLOOP,<tag1>]]%0A[[LOOP,<tag2>]] ... [[ENDLOOP,<tag2>]]%0A...%0A[[LOOP,<tagN>]] ... [[ENDLOOP,<tagN>]]%0A[[ENDSEQUENCE]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100020]:TAG|Y|Check for the type of the actual model element.|TAG(<tag>);
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100003]:VALUE|N|Export the properties of a model element.|[[VALUE,<tag>:<loop_spec>:<separator>]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100106]:comment|N|Text that is not exported.|[[* ... *]];
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100120]:parameters|N|The parameters specified on the command line can be selected for export. Only the replace functions L (lowercase) and U (uppercase) are supported.|<<<parm_nr>>>%0A<<<parm_nr>:<function>>>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100121]:parameters|Y|The parameters specified on the command line can be referenced in the %22is equal to%22 logical expression.|P<parm_number>=<value>;
	=CUBE_GEN_TEMPLATE_FUNCTION[CTF-000000100107]:replacement|N|Replace a label with a model value.|<<<tag>>>%0A<<<tag>(<location>)<property>:<function>>>;
-CUBE_GEN_DOCUMENTATION:Cube_Gen_Manual;
