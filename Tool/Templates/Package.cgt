Change log:
04-07-2017 Initial version
24-11-2017 Aliasses in READ_TABLE 
26-11-2017 Aliasses in READ_TABLE_RECURSIVE added
29-11-2017 Housekeepig (drop) added.
[[INCLUDE,Includes/general.cgt]]
[[INCLUDE,Includes/expression.cgt]]
[[TEXT,PACKAGE_PROC_SIGNATURE]]
	PROCEDURE <<PROCEDURE:L>> ([[LOOP,ARGUMENT]]
			<<ARGUMENT>> <<ARGUMENT1>> <<ARGUMENT2>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ARGUMENT]])[[ENDTEXT]]
[[TEXT,PACKAGE_SELECT]]
		SELECT[[IF:EVAL:'<<T1>>' eq 'SINGLE']] [[LOOP,GET]]<<TEXT,EXPRESSION>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]]
		INTO [[LOOP,GET]]<<GET>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]][[ELSE]][[LOOP,GET]]
		  <<TEXT,EXPRESSION>>[[IF:!0=]] <<GET>>[[ENDIF]][[IF:!LAST]],[[ENDIF]][[ENDLOOP,GET]][[ENDIF]]
		FROM [[LOOP,READ_TABLE]]<<READ_TABLE:L>>[[IF:!1=#]] <<READ_TABLE1:L>>[[ENDIF]][[IF:!LAST]], [[ENDIF]][[ENDLOOP,READ_TABLE]][[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]][[LOOP,SORT_ORDER]]
		ORDER BY <<TEXT,EXPRESSION>>[[ENDLOOP,SORT_ORDER]][[ENDTEXT]]
[[TEXT,PACKAGE_RECURSIVE_ATTRIBUTES]][[LOOP,READ_RECURSIVE_ATTRIBUTE]]
			<<T1>><<READ_RECURSIVE_ATTRIBUTE>>,[[ENDLOOP,READ_RECURSIVE_ATTRIBUTE]][[LOOP,READ_RECURSIVE_REFERENCE]][[LOOP,READ_RECURSIVE_FKEY]][[IF:!0=<<READ_RECURSIVE_FKEY1>>]]
			<<T1>><<READ_RECURSIVE_FKEY>>,[[ENDIF]][[ENDLOOP,READ_RECURSIVE_FKEY]][[ENDLOOP,READ_RECURSIVE_REFERENCE]][[ENDTEXT]]
[[TEXT,PACKAGE_WITH_SELECT]]
		WITH [[LOOP,READ_TABLE_RECURSIVE]]<<READ_TABLE_RECURSIVE1>> (<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|][|]>>
		cube_x_level) AS (
		SELECT[[TABS:+1]]<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|][|]>>[[TABS:-1]]
				0 
			FROM <<READ_TABLE_RECURSIVE>>[[FORV,STATEMENT:N>N]][[LOOP,SELECTION]]
		WHERE [[TABS:+1]]<<TEXT,EXPRESSION>>[[TABS:-1]][[ENDLOOP,SELECTION]][[ENDFOR]]
		UNION ALL
		SELECT[[TABS:+1]]<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|]<<READ_TABLE_RECURSIVE2>>.[|]>>[[TABS:-1]]
				<<READ_TABLE_RECURSIVE1>>.cube_x_level+1
			FROM <<READ_TABLE_RECURSIVE>> <<READ_TABLE_RECURSIVE2>>, <<READ_TABLE_RECURSIVE1>>[[LOOP,JOIN_SELECTION]]
		WHERE [[TABS:+1]]<<TEXT,EXPRESSION>>[[TABS:-1]][[ENDLOOP,JOIN_SELECTION]]
			)
		SELECT DISTINCT [[FORV,STATEMENT:N>N]][[LOOP,GET]]<<TEXT,EXPRESSION>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]][[ENDFOR]]
		FROM <<READ_TABLE_RECURSIVE1>>[[ENDLOOP,READ_TABLE_RECURSIVE]]
		WHERE cube_x_level > 0[[LOOP,SORT_ORDER]]
		ORDER BY <<TEXT,EXPRESSION>>[[ENDLOOP,SORT_ORDER]][[ENDTEXT]]
[[TEXT,PACKAGE_STATEMENTS]][[LOOP,STATEMENT]][[*
*]][[IF:0=SPACE]]
[[*
*]][[ELSIF:0=NOTE]]
		-- <<STATEMENT1>>[[*
*]][[ELSIF:0=SET]]
		<<STATEMENT1>> := <<TEXT,EXPRESSION>>;[[*
*]][[ELSIF:0=USE]]
		<<STATEMENT1>> <<TEXT,EXPRESSION>>;[[*
*]][[ELSIF:0=CREATE]]
		INSERT INTO <<STATEMENT1>> ([[LOOP,SET]]
			<<SET>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]])
		VALUES ([[LOOP,SET]]
			<<TEXT,EXPRESSION>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]]);[[*
*]][[ELSIF:0=UPDATE]]
		UPDATE <<STATEMENT1>> SET[[LOOP,SET]]
			<<SET>> = <<TEXT,EXPRESSION>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]][[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]];[[*
*]][[ELSIF:0=DELETE]]
		DELETE <<STATEMENT1>>[[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]];[[*
*]][[ELSIF:0=READ]]<<TEXT,PACKAGE_SELECT[|]<<STATEMENT1>>[|]>>;[[*
*]][[ELSIF:0=READ_EXPORT]]
	[[TABS:1]]OPEN p_cube_row FOR[[IF:CHILD(READ_TABLE_RECURSIVE)]]<<TEXT,PACKAGE_WITH_SELECT>>[[ELSE]]<<TEXT,PACKAGE_SELECT[|]CURSOR[|]>>[[ENDIF]];[[TABS:-1]][[*
*]][[ELSIF:0=SELECTION]][[IF:1=CASE]]
		CASE <<TEXT,EXPRESSION>>[[ENDIF]][[LOOP,STATEMENT_GROUP]][[IF,STATEMENT:1=IF]][[IF:CHILD(EXPRESSION)]]
		[[IF:!FIRST]]ELS[[ENDIF]]IF <<TEXT,EXPRESSION>> THEN[[ELSE]]
		ELSE[[ENDIF]][[ELSIF,STATEMENT:1=CASE]][[IF:CHILD(EXPRESSION)]]
		WHEN <<TEXT,EXPRESSION>> THEN[[ELSE]]
		ELSE[[ENDIF]][[ENDIF]][[REPEAT,STATEMENT:TAB]][[ENDLOOP,STATEMENT_GROUP]][[IF:1=IF]]
		END IF;[[ELSIF:1=CASE]]
		END CASE;[[ENDIF]][[*
*]][[ELSIF:0=ITERATION]][[IF:1=cursor]]
	[[TABS:1]]FOR <<STATEMENT2>> IN (<<TEXT,PACKAGE_SELECT[|]CURSOR[|]>>)[[TABS:-1]][[ENDIF]]
		LOOP[[REPEAT:TAB]]
		END LOOP;[[*
*]][[ELSIF:0=STOP_ITERATION]]
		EXIT;[[*
*]][[ENDIF]][[LOOP,REMARK]] -- <<REMARK>>[[ENDLOOP,REMARK]][[ENDLOOP,STATEMENT]][[ENDTEXT]]
[[BODY]]-- <<1:U>> Packages
--
BEGIN
	FOR r_p IN (
		SELECT object_name
		FROM user_procedures
		WHERE procedure_name = 'CUBE_PKG_<<1:U>>' )
	LOOP
		EXECUTE IMMEDIATE 'DROP PACKAGE '||r_p.object_name;
	END LOOP;
END;
/[[IF:!0=CubeSys]]
CREATE OR REPLACE PACKAGE pkg_cube IS
	FUNCTION cube_pkg_<<1:L>> RETURN VARCHAR2;
	FUNCTION years(p_date DATE) RETURN NUMBER;
	FUNCTION multiply(p_num_1 NUMBER, p_num_2 NUMBER) RETURN NUMBER;
	FUNCTION add(p_num_1 NUMBER, p_num_2 NUMBER) RETURN NUMBER;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg_cube IS
	FUNCTION cube_pkg_<<1:L>> RETURN VARCHAR2 IS
	BEGIN
		RETURN 'cube_pkg_<<1:L>>';
	END;
	FUNCTION years(p_date DATE) RETURN NUMBER IS
	BEGIN
		RETURN (TRUNC(MONTHS_BETWEEN (CURRENT_DATE, p_date) / 12));
	END;
	FUNCTION multiply(p_num_1 NUMBER, p_num_2 NUMBER) RETURN NUMBER IS
	BEGIN
		RETURN (p_num_1 * p_num_2);
	END;
	FUNCTION add(p_num_1 NUMBER, p_num_2 NUMBER) RETURN NUMBER IS
	BEGIN
		RETURN (p_num_1 + p_num_2);
	END;
END;
/[[ENDIF]][[LOOP,PACKAGE]]
CREATE OR REPLACE PACKAGE <<PACKAGE:L>> IS
[[LOOP,TYPE]]
	TYPE <<TYPE:L>> IS [[IF:1=CURSOR]]REF CURSOR;[[ENDIF]][[ENDLOOP,TYPE]]
	FUNCTION cube_pkg_<<1:L>> RETURN VARCHAR2;[[LOOP,PROCEDURE:1=Y]]<<TEXT,PACKAGE_PROC_SIGNATURE>>;[[ENDLOOP,PROCEDURE]]
END;
/
SHOW ERRORS;

CREATE OR REPLACE PACKAGE BODY <<PACKAGE:L>> IS
	FUNCTION cube_pkg_<<1:L>> RETURN VARCHAR2 IS
	BEGIN
		RETURN 'cube_pkg_<<1:L>>';
	END;[[LOOP,PROCEDURE]]
<<TEXT,PACKAGE_PROC_SIGNATURE>> IS[[LOOP,VARIABLE]]
		<<VARIABLE>> <<VARIABLE1>>[[IF:CHILD(EXPRESSION)]] := <<TEXT,EXPRESSION>>[[ENDIF]];[[ENDLOOP,VARIABLE]]
	BEGIN<<TEXT,PACKAGE_STATEMENTS>>[[IF:CHILD(EXCEPTION)]]
	EXCEPTION[[LOOP,EXCEPTION]]
	WHEN <<EXCEPTION>> THEN[[TABS:1]]<<TEXT,PACKAGE_STATEMENTS>>[[TABS:-1]][[ENDLOOP,EXCEPTION]][[ENDIF]]
	END;[[ENDLOOP,PROCEDURE]]
END;
/
SHOW ERRORS;
[[ENDLOOP,PACKAGE]]
EXIT;[[ENDBODY]]