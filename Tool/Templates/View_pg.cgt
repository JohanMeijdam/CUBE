Change log:
10-08-2016 - Foreign Keys to lowest level:
-	When inserting copy non key FK's from the parent	
21-08-2016 - RERERENCE renamed to EXTERNAL_REFERENCE
16-10-2016 - EXTERNAL_REFERENCE to RERERENCE
12-07-2017 - CUBE_ID niet meer via de view
25-10-2017 - Using trigger package
13-11-2017 - Use of ROWID added / DR triggers added
10-03-2018 - Unchangeable attributes not updating.
13-09-2018 - NVL function for primary keys with a RESTRICTION_TYPE_SPEC_ATB
04-09-2019 - Sequence name to SQ_name
04-09-2019 - Drop Views and Packages
02-02-2020 - In case of create NVL for all primary keys.
14-11-2021 - Migration to Postgresql
20-06-2024 - Excluding CUBE-NULL rows and NVL in insert only for primary keys.
[[INCLUDE,Includes/general.cgt]]
[[INCLUDE,Includes/expression_pg.cgt]]
[[TEXT,VIEW_CHANGEABLE_ATTRIBUTE]]!CHILD(DERIVATION:0=ID)[AND]!1=Y[AND]!6=Y[[ENDTEXT]]
[[TEXT,VIEW_SELECT_PARENT_FKEYS]]
		SELECT [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N)]]<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		  INTO [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N)]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		FROM <<TYPE(1)1:L>>.t_<<TYPE(N-1):L>>
		WHERE cube_id <> 'CUBE-NULL'[[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=Y)]]
		  AND [[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[ENDLOOP,ATTRIBUTE]];[[ENDTEXT]]
[[BODY]]-- DB VIEW DDL
--[[LOOP,SYSTEM:0=<<1>>]]
DO $BODY$
	DECLARE
		rec_view RECORD;
		rec_proc RECORD;
	BEGIN[[LOOP,SYSTEM_BO_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]

		FOR rec_view IN 
			SELECT viewname 
			FROM pg_catalog.pg_views
			WHERE schemaname = '<<TYPE1:L>>'
			  AND viewowner = '<<2>>'[[IF,SYSTEM:1=SUPPORT]]
			  AND SUBSTR(viewname,1,INSTR(viewname,'_',3)) = 'V_<<SYSTEM5:U>>_'[[ELSE]][[FOR,ROOT]][[IF:CHILD(SYSTEM:1=SUPPORT)]]
			  AND COALESCE(SUBSTR(viewname,1,INSTR(viewname,'_',3)),' ') NOT IN ([[LOOP,SYSTEM:1=SUPPORT]]'V_<<SYSTEM5:U>>_'[[IF:!LAST]], [[ENDIF]][[ENDLOOP,SYSTEM]])[[ENDIF]][[ENDFOR]][[ENDIF]]
		LOOP
			EXECUTE 'DROP VIEW <<TYPE1:L>>.' || rec_view.viewname || ' CASCADE';
		END LOOP;[[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[ENDLOOP,SYSTEM_BO_TYPE]][[LOOP,SYSTEM_BO_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]

		FOR rec_proc IN
			SELECT proname, prokind
			FROM pg_catalog.pg_proc, pg_catalog.pg_namespace, pg_catalog.pg_user
			WHERE pronamespace = pg_namespace.oid
			  AND nspowner = usesysid
			  AND usename = '<<2>>'
			  AND nspname = '<<TYPE1:L>>'
			  AND proname LIKE 'trg_%'
		LOOP
			CASE rec_proc.prokind
			WHEN 'p' THEN EXECUTE 'DROP PROCEDURE <<TYPE1:L>>.' || rec_proc.proname;
			WHEN 'f' THEN EXECUTE 'DROP FUNCTION <<TYPE1:L>>.' || rec_proc.proname;
			END CASE;
		END LOOP;[[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[ENDLOOP,SYSTEM_BO_TYPE]]
	END;
$BODY$;[[LOOP,SYSTEM_BO_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]

CREATE VIEW <<TYPE(1)1:L>>.v_<<TYPE:L>> AS 
	SELECT[[LOOP,ATTRIBUTE]]
		<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]
	FROM <<TYPE(1)1:L>>.t_<<TYPE:L>>;
[[REPEAT]][[ENDLOOP,TYPE]][[LOOP,TYPE]]

CREATE PROCEDURE <<TYPE(1)1:L>>.trg_insert_<<TYPE1:L>> (p_<<TYPE1:L>> <<TYPE(1)1:L>>.v_<<TYPE:L>>)
LANGUAGE plpgsql 
AS $BODY$
	BEGIN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:0=ID)]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := '[[IF,SYSTEM:0=CubeRoot]]CUBE-[[ENDIF]]<<TYPE1:U>>-' || TO_CHAR(NEXTVAL('<<TYPE(1)1:L>>.sq_<<TYPE1:L>>'),'FM[[IF,SYSTEM:!0=CubeRoot[AND]!0=CubeSys]]00000[[ENDIF]]0000000');[[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:!CHILD(DERIVATION)[AND](1=Y)]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := COALESCE(p_<<TYPE1:L>>.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE_ITE>>);[[ENDLOOP,ATTRIBUTE]][[IF:3=Y]][[IF:CHILD(ATTRIBUTE:3=F[AND]1=N)]]
		IF [[LOOP,ATTRIBUTE:3=R]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>> IS NOT NULL [[IF:!LAST]]OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]]THEN
			-- Recursive[[* If root parent has FK not in PK then recursive parent allways will have it *]]
			SELECT [[LOOP,ATTRIBUTE:3=F[AND]1=N]]<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
			  INTO [[LOOP,ATTRIBUTE:3=F[AND]1=N]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
			FROM <<TYPE(1)1:L>>.t_<<TYPE:L>>
			WHERE [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=Y)[OR]3=R]][[IF:3=F]]<<ATTRIBUTE:L>>[[ELSE]][[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]][[ENDIF]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];[[IF:CHILD(ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N))]]
		ELSE
		-- Parent[[TABS:+1]]<<TEXT,VIEW_SELECT_PARENT_FKEYS>>[[TABS:-1]]
			[[ENDIF]]
		END IF;[[ENDIF]][[ELSIF:CHILD(ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N))]]<<TEXT,VIEW_SELECT_PARENT_FKEYS>>[[ENDIF]][[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		CALL <<TYPE(1)1:L>>.trg_get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>);[[ENDIF]]
		INSERT INTO <<TYPE(1)1:L>>.t_<<TYPE:L>> ([[LOOP,ATTRIBUTE]]
			<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]])
		VALUES ([[LOOP,ATTRIBUTE]]
			p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]);
	END;
$BODY$;

CREATE PROCEDURE <<TYPE(1)1:L>>.trg_update_<<TYPE1:L>> (p_cube_ctid TID, p_<<TYPE1:L>>_old <<TYPE(1)1:L>>.v_<<TYPE:L>>, p_<<TYPE1:L>>_new <<TYPE(1)1:L>>.v_<<TYPE:L>>)
LANGUAGE plpgsql
AS $BODY$[[IF:CHILD(ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
	DECLARE[[* Nu nog even voor recursief childs dit ook doen voor alle child records intern en extern *]]
		c_<<TYPE1:L>> CURSOR FOR
			SELECT CTID cube_ctid, <<TYPE1:L>>.* FROM <<TYPE(1)1:L>>.v_<<TYPE:L>> <<TYPE1:L>>
			WHERE [[LOOP,ATTRIBUTE:1=Y[AND]3=F]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>
			  AND [[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:3=R]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_old.[[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]][[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];
		
		l_<<TYPE1:L>>_ctid TID;
		r_<<TYPE1:L>>_old <<TYPE(1)1:L>>.v_<<TYPE:L>>%ROWTYPE;
		r_<<TYPE1:L>>_new <<TYPE(1)1:L>>.v_<<TYPE:L>>%ROWTYPE;[[ENDIF]]
	BEGIN[[IF:CHILD(ATTRIBUTE:<<TEXT,VIEW_CHANGEABLE_ATTRIBUTE>>)]][[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		IF [[LOOP,ATTRIBUTE:3=R]]COALESCE(p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE_ITE>>) <> COALESCE(p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE_ITE>>) [[IF:!LAST]]
		OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			CALL <<TYPE(1)1:L>>.trg_get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>_new);
		END IF;[[ENDIF]]
		UPDATE <<TYPE(1)1:L>>.t_<<TYPE:L>> SET [[LOOP,ATTRIBUTE:<<TEXT,VIEW_CHANGEABLE_ATTRIBUTE>>]]
			<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		WHERE ctid = p_cube_ctid;[[ELSE]]
		NULL;[[ENDIF]][[IF:CHILD(ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		IF [[LOOP,ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>))]]COALESCE(p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE_ITE>>) <> COALESCE(p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE_ITE>>)[[IF:!LAST]]
		OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			OPEN c_<<TYPE1:L>>;
			LOOP
				FETCH c_<<TYPE1:L>> INTO
					l_<<TYPE1:L>>_ctid[[LOOP,ATTRIBUTE]],
					r_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>[[ENDLOOP,ATTRIBUTE]];
				EXIT WHEN NOT FOUND;
				r_<<TYPE1:L>>_new := r_<<TYPE1:L>>_old;
				CALL <<TYPE(1)1:L>>.trg_denorm_<<TYPE1:L>>_<<TYPE1:L>> (r_<<TYPE1:L>>_new, p_<<TYPE1:L>>_new);
				CALL <<TYPE(1)1:L>>.trg_update_<<TYPE1:L>> (l_<<TYPE1:L>>_ctid, r_<<TYPE1:L>>_old, r_<<TYPE1:L>>_new);
			END LOOP;
			CLOSE c_<<TYPE1:L>>;
		END IF;[[ENDIF]]
	END;
$BODY$;

CREATE PROCEDURE <<TYPE(1)1:L>>.trg_delete_<<TYPE1:L>> (p_cube_ctid TID, p_<<TYPE1:L>> <<TYPE(1)1:L>>.v_<<TYPE:L>>)
LANGUAGE plpgsql 
AS $BODY$
	BEGIN
		DELETE FROM <<TYPE(1)1:L>>.t_<<TYPE:L>> 
		WHERE ctid = p_cube_ctid;
	END;
$BODY$;[[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
[[* Nu nog even voor recursief parent dit ook doen voor alle parent records intern en extern *]]
CREATE PROCEDURE <<TYPE(1)1:L>>.trg_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> <<TYPE(1)1:L>>.v_<<TYPE:L>>, p_<<TYPE1:L>>_in <<TYPE(1)1:L>>.v_<<TYPE:L>>)
LANGUAGE plpgsql 
AS $BODY$
	BEGIN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>))]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := [[LOOP,DERIVATION]]<<TEXT,EXPRESSION[|]p_<<TYPE1:L>>_in[|]>>[[ENDLOOP,DERIVATION]];[[ENDLOOP,ATTRIBUTE]]
	END;
$BODY$;

CREATE PROCEDURE <<TYPE(1)1:L>>.trg_get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> <<TYPE(1)1:L>>.v_<<TYPE:L>>)
LANGUAGE plpgsql 
AS $BODY$
	DECLARE
		c_<<TYPE1:L>> CURSOR FOR 
			SELECT * FROM <<TYPE(1)1:L>>.v_<<TYPE:L>>
			WHERE [[LOOP,ATTRIBUTE:1=Y[AND]3=F]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>
			  AND [[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:3=R]][[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];
		
		r_<<TYPE1:L>> <<TYPE(1)1:L>>.v_<<TYPE:L>>%ROWTYPE;
	BEGIN
		IF [[LOOP,ATTRIBUTE:3=R]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>> IS NOT NULL[[IF:!LAST]] AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			OPEN c_<<TYPE1:L>>;
			FETCH c_<<TYPE1:L>> INTO r_<<TYPE1:L>>;
			IF NOT FOUND THEN
				r_<<TYPE1:L>> := NULL;
			END IF;
			CLOSE c_<<TYPE1:L>>;
		ELSE
			r_<<TYPE1:L>> := NULL;
		END IF;
		CALL <<TYPE(1)1:L>>.trg_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>, r_<<TYPE1:L>>);
	END;
$BODY$;[[ENDIF]][[REPEAT]][[ENDLOOP,TYPE]][[LOOP,TYPE]]

CREATE FUNCTION <<TYPE(1)1:L>>.trg_<<TYPE1:L>>() RETURNS trigger
LANGUAGE plpgsql 
AS $BODY$
	DECLARE
		l_cube_ctid TID;
		r_<<TYPE1:L>>_new <<TYPE(1)1:L>>.v_<<TYPE:L>>%ROWTYPE;
		r_<<TYPE1:L>>_old <<TYPE(1)1:L>>.v_<<TYPE:L>>%ROWTYPE;
	BEGIN
		IF TG_OP IN ('INSERT','UPDATE') THEN[[LOOP,ATTRIBUTE:!CHILD(DERIVATION:!0=SQ)]][[LOOP,INFORMATION_TYPE_ELEMENT]][[IF:2=TEXT[AND]7=N]]
			IF NEW.<<ATTRIBUTE:L>> = ' ' THEN
				r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := ' ';
			ELSE
				r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := REPLACE(NEW.<<ATTRIBUTE:L>>,' ','_');
			END IF;[[IF:5=N]]
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := UPPER(r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>);[[ENDIF]][[ELSIF:2=TEXT[AND]5=N]]
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := UPPER(NEW.<<ATTRIBUTE:L>>);[[ELSE]]
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := NEW.<<ATTRIBUTE:L>>;[[ENDIF]][[ENDLOOP,INFORMATION_TYPE_ELEMENT]][[ENDLOOP,ATTRIBUTE]]
		END IF;[[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:!0=SQ))]][[* In case of a derivation the old value is taken by default *]]
		IF TG_OP IN ('UPDATE') THEN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:!0=SQ)]]
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := OLD.<<ATTRIBUTE:L>>;[[ENDLOOP,ATTRIBUTE]]
		END IF;[[ENDIF]]
		IF TG_OP IN ('UPDATE','DELETE') THEN
			SELECT ctid INTO l_cube_ctid FROM <<TYPE(1)1:L>>.t_<<TYPE:L>>
			WHERE [[LOOP,ATTRIBUTE:1=Y]]<<ATTRIBUTE:L>> = OLD.<<ATTRIBUTE:L>>[[IF:!LAST]]
			AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];[[LOOP,ATTRIBUTE:!CHILD(DERIVATION:!0=SQ)]]
			r_<<TYPE1:L>>_old.<<ATTRIBUTE:L>> := OLD.<<ATTRIBUTE:L>>;[[ENDLOOP,ATTRIBUTE]]
		END IF;

		IF TG_OP = 'INSERT' THEN 
			CALL <<TYPE(1)1:L>>.trg_insert_<<TYPE1:L>> (r_<<TYPE1:L>>_new);
			RETURN NEW;
		ELSIF TG_OP = 'UPDATE' THEN
			CALL <<TYPE(1)1:L>>.trg_update_<<TYPE1:L>> (l_cube_ctid, r_<<TYPE1:L>>_old, r_<<TYPE1:L>>_new);
			RETURN NEW;
		ELSIF TG_OP = 'DELETE' THEN
			CALL <<TYPE(1)1:L>>.trg_delete_<<TYPE1:L>> (l_cube_ctid, r_<<TYPE1:L>>_old);
			RETURN OLD;
		END IF;
		RETURN NULL;
	END;
$BODY$;

CREATE TRIGGER trg_<<TYPE1:L>>
INSTEAD OF INSERT OR DELETE OR UPDATE ON <<TYPE(1)1:L>>.v_<<TYPE:L>>
FOR EACH ROW
EXECUTE PROCEDURE <<TYPE(1)1:L>>.trg_<<TYPE1:L>>();[[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[ENDLOOP,SYSTEM_BO_TYPE]][[ENDLOOP,SYSTEM]]

\q
[[ENDBODY]]