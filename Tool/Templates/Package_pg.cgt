Change log:
04-07-2017 Initial version
24-11-2017 Aliasses in READ_TABLE 
26-11-2017 Aliasses in READ_TABLE_RECURSIVE added
29-11-2017 Housekeepig (drop) added.
15-12-2021 pkg prefix added.
18-12-2021 use of GEN_DOMAIN_TEXT_PG
16-02-2022 Cursor definition based on FlagCursorExport
06-04-2002 Exception with code
[[INCLUDE,Includes/general.cgt]]
[[INCLUDE,Includes/expression.cgt]]
[[TEXT,PACKAGE_SELECT]]
		SELECT[[IF:EVAL:'<<T1>>' eq 'SINGLE']] [[LOOP,GET]]<<TEXT,EXPRESSION>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]]
		INTO [[LOOP,GET]]<<GET>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]][[ELSE]][[LOOP,GET]]
		  <<TEXT,EXPRESSION>>[[IF:!0=]] <<GET>>[[ENDIF]][[IF:!LAST]],[[ENDIF]][[ENDLOOP,GET]][[ENDIF]]
		FROM [[LOOP,READ_TABLE]]<<PACKAGE:L>>.<<READ_TABLE:L>>[[IF:!1=#]] <<READ_TABLE1:L>>[[ENDIF]][[IF:!LAST]], [[ENDIF]][[ENDLOOP,READ_TABLE]][[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]][[LOOP,SORT_ORDER]]
		ORDER BY <<TEXT,EXPRESSION>>[[ENDLOOP,SORT_ORDER]][[ENDTEXT]]
[[TEXT,PACKAGE_RECURSIVE_ATTRIBUTES]][[LOOP,READ_RECURSIVE_ATTRIBUTE]]
			<<T1>><<READ_RECURSIVE_ATTRIBUTE>>,[[ENDLOOP,READ_RECURSIVE_ATTRIBUTE]][[LOOP,READ_RECURSIVE_REFERENCE]][[LOOP,READ_RECURSIVE_FKEY]][[IF:!0=<<READ_RECURSIVE_FKEY1>>]]
			<<T1>><<READ_RECURSIVE_FKEY>>,[[ENDIF]][[ENDLOOP,READ_RECURSIVE_FKEY]][[ENDLOOP,READ_RECURSIVE_REFERENCE]][[ENDTEXT]]
[[TEXT,PACKAGE_WITH_SELECT]]
		WITH [[LOOP,READ_TABLE_RECURSIVE]]<<READ_TABLE_RECURSIVE1>> (<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|][|]>>
		cube_x_level) AS (
		SELECT[[TABS:+1]]<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|][|]>>[[TABS:-1]]
				0 
			FROM <<PACKAGE:L>>.<<READ_TABLE_RECURSIVE>>[[FORV,STATEMENT:N>N]][[LOOP,SELECTION]]
		WHERE [[TABS:+1]]<<TEXT,EXPRESSION>>[[TABS:-1]][[ENDLOOP,SELECTION]][[ENDFOR]]
		UNION ALL
		SELECT[[TABS:+1]]<<TEXT,PACKAGE_RECURSIVE_ATTRIBUTES[|]<<READ_TABLE_RECURSIVE2>>.[|]>>[[TABS:-1]]
				<<READ_TABLE_RECURSIVE1>>.cube_x_level+1
			FROM <<PACKAGE:L>>.<<READ_TABLE_RECURSIVE>> <<READ_TABLE_RECURSIVE2>>, <<READ_TABLE_RECURSIVE1>>[[LOOP,JOIN_SELECTION]]
		WHERE [[TABS:+1]]<<TEXT,EXPRESSION>>[[TABS:-1]][[ENDLOOP,JOIN_SELECTION]]
			)
		SELECT DISTINCT [[FORV,STATEMENT:N>N]][[LOOP,GET]]<<TEXT,EXPRESSION>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,GET]][[ENDFOR]]
		FROM <<PACKAGE:L>>.<<READ_TABLE_RECURSIVE1>>[[ENDLOOP,READ_TABLE_RECURSIVE]]
		WHERE cube_x_level > 0[[LOOP,SORT_ORDER]]
		ORDER BY <<TEXT,EXPRESSION>>[[ENDLOOP,SORT_ORDER]][[ENDTEXT]]
[[TEXT,PACKAGE_STATEMENTS]][[LOOP,STATEMENT]][[*
*]][[IF:0=SPACE]]
[[*
*]][[ELSIF:0=NOTE]]
		-- <<STATEMENT1>>[[*
*]][[ELSIF:0=SET]]
		<<STATEMENT1>> := <<TEXT,EXPRESSION>>;[[*
*]][[ELSIF:0=USE]]
		CALL <<PACKAGE:L>>.<<STATEMENT1>> <<TEXT,EXPRESSION>>;[[*
*]][[ELSIF:0=CREATE]]
		INSERT INTO <<PACKAGE:L>>.<<STATEMENT1>> ([[LOOP,SET]]
			<<SET>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]])
		VALUES ([[LOOP,SET]]
			<<TEXT,EXPRESSION>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]]);[[*
*]][[ELSIF:0=UPDATE]]
		UPDATE <<PACKAGE:L>>.<<STATEMENT1>> SET[[LOOP,SET]]
			<<SET>> = <<TEXT,EXPRESSION>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,SET]][[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]];[[*
*]][[ELSIF:0=DELETE]]
		DELETE FROM <<PACKAGE:L>>.<<STATEMENT1>>[[LOOP,SELECTION]]
		WHERE <<TEXT,EXPRESSION>>[[ENDLOOP,SELECTION]];[[*
*]][[ELSIF:0=READ]]<<TEXT,PACKAGE_SELECT[|]<<STATEMENT1>>[|]>>;[[*
*]][[ELSIF:0=READ_EXPORT]]
	[[TABS:1]]OPEN l_cube_cursor FOR[[IF:CHILD(READ_TABLE_RECURSIVE)]]<<TEXT,PACKAGE_WITH_SELECT>>[[ELSE]]<<TEXT,PACKAGE_SELECT[|]CURSOR[|]>>[[ENDIF]];[[TABS:-1]][[*
*]][[ELSIF:0=SELECTION]][[IF:1=CASE]]
		CASE <<TEXT,EXPRESSION>>[[ENDIF]][[LOOP,STATEMENT_GROUP]][[IF,STATEMENT:1=IF]][[IF:CHILD(EXPRESSION)]]
		[[IF:!FIRST]]ELS[[ENDIF]]IF <<TEXT,EXPRESSION>> THEN[[ELSE]]
		ELSE[[ENDIF]][[ELSIF,STATEMENT:1=CASE]][[IF:CHILD(EXPRESSION)]]
		WHEN <<TEXT,EXPRESSION>> THEN[[ELSE]]
		ELSE[[ENDIF]][[ENDIF]][[REPEAT,STATEMENT:TAB]][[ENDLOOP,STATEMENT_GROUP]][[IF:1=IF]]
		END IF;[[ELSIF:1=CASE]]
		END CASE;[[ENDIF]][[*
*]][[ELSIF:0=ITERATION]][[IF:1=cursor]]
	[[TABS:1]]FOR <<STATEMENT2>> IN <<TEXT,PACKAGE_SELECT[|]CURSOR[|]>>[[TABS:-1]][[ENDIF]]
		LOOP[[REPEAT:TAB]]
		END LOOP;[[*
*]][[ELSIF:0=STOP_ITERATION]]
		EXIT;[[*
*]][[ENDIF]][[LOOP,REMARK]] -- <<REMARK>>[[ENDLOOP,REMARK]][[ENDLOOP,STATEMENT]][[ENDTEXT]]
[[BODY]]-- <<1:U>> Stored procedures
--[[LOOP,PACKAGE]][[IF:0=cube]]
DO $BODY$
	DECLARE
		rec_nspname RECORD;
	BEGIN
		FOR rec_nspname IN 
			SELECT nspname 
			FROM pg_catalog.pg_namespace, pg_catalog.pg_user
			WHERE nspowner = usesysid
			  AND usename = '<<PACKAGE1>>'
			  AND nspname = '<<PACKAGE>>'
		LOOP
			EXECUTE 'DROP SCHEMA ' || rec_nspname.nspname || ' CASCADE';
		END LOOP;
	END;
$BODY$;

CREATE SCHEMA cube;

CREATE FUNCTION cube.years(p_date DATE) RETURNS NUMERIC
LANGUAGE plpgsql 
AS $BODY$
	BEGIN
		RETURN DATE_PART('YEAR',AGE(CURRENT_TIMESTAMP, p_date));
	END;
$BODY$;

CREATE FUNCTION cube.multiply(p_num_1 NUMERIC, p_num_2 NUMERIC) RETURNS NUMERIC
LANGUAGE plpgsql 
AS $BODY$
	BEGIN
		RETURN p_num_1 * p_num_2;
	END;
$BODY$;

CREATE FUNCTION cube.add(p_num_1 NUMERIC, p_num_2 NUMERIC) RETURNS NUMERIC
LANGUAGE plpgsql 
AS $BODY$
	BEGIN
		RETURN p_num_1 + p_num_2;
	END;
$BODY$;[[ELSE]]

DO $BODY$
	DECLARE
		rec_proc RECORD;
	BEGIN
		FOR rec_proc IN
			SELECT proname, prokind
			FROM pg_catalog.pg_proc, pg_catalog.pg_namespace, pg_catalog.pg_user
			WHERE pronamespace = pg_namespace.oid
			  AND nspowner = usesysid
			  AND usename = '<<PACKAGE1:L>>'
			  AND nspname = '<<PACKAGE>>'
			  AND proname NOT LIKE 'trg_%'
		LOOP
			CASE rec_proc.prokind
			WHEN 'p' THEN EXECUTE 'DROP PROCEDURE <<PACKAGE>>.' || rec_proc.proname;
			WHEN 'f' THEN EXECUTE 'DROP FUNCTION <<PACKAGE>>.' || rec_proc.proname;
			END CASE;
		END LOOP;
	END;
$BODY$;[[IF:0=zzz]]

CREATE OR REPLACE PROCEDURE itp.get_itp_root_items()
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	l_cube_cursor REFCURSOR := 'cube_cursor';
BEGIN
    OPEN l_cube_cursor FOR 
		SELECT
			  name
		FROM itp.v_information_type
		ORDER BY name;
END;
$BODY$;[[ENDIF]][[LOOP,PROCEDURE]]

CREATE PROCEDURE <<PACKAGE:L>>.<<PROCEDURE:L>> ([[LOOP,ARGUMENT]]
			<<ARGUMENT>> [[IF:1=I]]IN[[ELSIF:1=O]]INOUT[[ELSIF:1=B]]INOUT[[ENDIF]] <<TEXT,GEN_DOMAIN_TEXT_PG>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ARGUMENT]])
LANGUAGE 'plpgsql'
AS $BODY$
	DECLARE[[IF:2=Y]]
		l_cube_cursor REFCURSOR := 'cube_cursor';[[ENDIF]][[LOOP,VARIABLE]]
		<<VARIABLE>> <<TEXT,GEN_DOMAIN_PG[|]<<VARIABLE3>>[|]<<VARIABLE4>>[|]>>[[IF:CHILD(EXPRESSION)]] := <<TEXT,EXPRESSION>>[[ENDIF]];[[ENDLOOP,VARIABLE]][[LOOP,CURSOR]]
		<<CURSOR>> RECORD;[[ENDLOOP,CURSOR]]
	BEGIN<<TEXT,PACKAGE_STATEMENTS>>[[IF:CHILD(EXCEPTION)]]
	EXCEPTION[[LOOP,EXCEPTION]]
	WHEN [[IF:0=E001]]unique_violation[[ELSE]]unknown[[ENDIF]] THEN[[TABS:1]]<<TEXT,PACKAGE_STATEMENTS>>[[TABS:-1]][[ENDLOOP,EXCEPTION]][[ENDIF]]
	END;
$BODY$;[[ENDLOOP,PROCEDURE]][[ENDIF]][[ENDLOOP,PACKAGE]]
\q
[[ENDBODY]]